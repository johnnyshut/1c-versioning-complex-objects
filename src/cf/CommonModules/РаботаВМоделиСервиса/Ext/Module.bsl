///////////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2021, ООО 1С-Софт
// Все права защищены. Эта программа и сопроводительные материалы предоставляются 
// в соответствии с условиями лицензии Attribution 4.0 International (CC BY 4.0)
// Текст лицензии доступен по ссылке:
// https://creativecommons.org/licenses/by/4.0/legalcode
///////////////////////////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

// Возвращает имя общего реквизита, который является разделителем основных данных.
//
// Возвращаемое значение:
//   Строка - имя общего реквизита, который является разделителем основных данных.
//
Функция РазделительОсновныхДанных() Экспорт
	
	Возврат Метаданные.ОбщиеРеквизиты.ОбластьДанныхОсновныеДанные.Имя;
	
КонецФункции

// Возвращает имя общего реквизита, который является разделителем вспомогательных данных.
//
// Возвращаемое значение:
//   Строка - имя общего реквизита, который является разделителем вспомогательных данных.
//
Функция РазделительВспомогательныхДанных() Экспорт
	
	Возврат Метаданные.ОбщиеРеквизиты.ОбластьДанныхВспомогательныеДанные.Имя;
	
КонецФункции

// Возвращает признак работы в режиме разделения данных по областям
// (технически это признак условного разделения).
// 
// Возвращает Ложь, если конфигурация не может работать в режиме разделения данных
// (не содержит общих реквизитов, предназначенных для разделения данных).
//
// Возвращаемое значение:
//  Булево - Истина, если разделение включено.
//         - Ложь,   если разделение выключено или не поддерживается.
//
Функция РазделениеВключено() Экспорт
	
	Возврат РаботаВМоделиСервисаПовтИсп.РазделениеВключено();
	
КонецФункции

// Возвращает признак возможности обращения к разделенным данным (которые входят в состав разделителей).
// Признак относится к сеансу, но может меняться во время работы сеанса, если разделение было включено
// в самом сеансе, поэтому проверку следует делать непосредственно перед обращением к разделенным данным.
// 
// Возвращает Истина, если конфигурация не может работать в режиме разделения данных
// (не содержит общих реквизитов, предназначенных для разделения данных).
//
// Возвращаемое значение:
//   Булево - Истина, если разделение не поддерживается, либо разделение выключено,
//                    либо разделение включено и разделители    установлены.
//          - Ложь,   если разделение включено и разделители не установлены.
//
Функция ДоступноИспользованиеРазделенныхДанных() Экспорт
	
	Если Не РазделениеВключено() Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат ИспользованиеРазделителяСеанса();
	
КонецФункции

// Очищает все параметры сеанса, кроме связанных с общим 
// реквизитом ОбластьДанных.
//
Процедура ОчиститьВсеПараметрыСеансаКромеРазделителей() Экспорт
	
	ОбщегоНазначения.ОчиститьПараметрыСеанса(, "ОбластьДанныхЗначение,ОбластьДанныхИспользование");
	
КонецПроцедуры

// Проверяет блокировку области данных.
//
// Параметры:
//  ОбластьДанных -  Число - значение разделителя области данных, 
//   блокировку которой требуется проверить.
//
// Возвращаемое значение:
//  Булево - если Истина, область данных заблокирована, иначе нет.
//
Функция ОбластьДанныхЗаблокирована(Знач ОбластьДанных) Экспорт
	
	Ключ = СоздатьКлючЗаписиРегистраСведенийВспомогательныхДанных(
	    РегистрыСведений.ОбластиДанных,
	    Новый Структура(РазделительВспомогательныхДанных(), ОбластьДанных));
	
	Попытка
		
		ЗаблокироватьДанныеДляРедактирования(Ключ);
		
	Исключение
		
		Возврат Истина;
		
	КонецПопытки;
	
	РазблокироватьДанныеДляРедактирования(Ключ);
	
	Если НЕ ДоступноИспользованиеРазделенныхДанных() Тогда
		
		Попытка
			
			УстановитьРазделениеСеанса(Истина, ОбластьДанных);
			
		Исключение
			
			УстановитьРазделениеСеанса(Ложь);
			Возврат Истина;
			
		КонецПопытки;
		
		УстановитьРазделениеСеанса(Ложь);
		
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Подготавливает область данных к использованию. Запускает процедура обновления ИБ,
// при необходимости заполняет демонстрационными данными, устанавливает новый статус в регистре ОбластиДанных.
// 
// Параметры: 
//   ОбластьДанных - Число - значение разделителя области данных, которую необходимо подготовить к использованию.
//   ИДФайлаВыгрузки - УникальныйИдентификатор - идентификатор файла.
//   Вариант - Строка - вариант начальных данных.
// 
Процедура ПодготовитьОбластьДанныхКИспользованию(Знач ОбластьДанных, Знач ИДФайлаВыгрузки, 
												 Знач Вариант = Неопределено) Экспорт
	
	Если НЕ Пользователи.ЭтоПолноправныйПользователь(, Истина) Тогда
		ВызватьИсключение(НСтр("ru = 'Недостаточно прав для выполнения операции'"));
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	КлючОбласти = СоздатьКлючЗаписиРегистраСведенийВспомогательныхДанных(
		РегистрыСведений.ОбластиДанных,
		Новый Структура(РазделительВспомогательныхДанных(), ОбластьДанных));
	ЗаблокироватьДанныеДляРедактирования(КлючОбласти);
	
	Попытка
		МенеджерЗаписи = ПолучитьМенеджерЗаписиОбластиДанных(ОбластьДанных, Перечисления.СтатусыОбластейДанных.Новая);
		
		Если ТекущийРежимЗапуска() <> Неопределено Тогда
			
			ПользователиСлужебный.АвторизоватьТекущегоПользователя();
			
		КонецЕсли;
		
		СообщениеОбОшибке = "";
		Если Не ЗначениеЗаполнено(Вариант) Тогда
			
			РезультатПодготовки = ПодготовитьОбластьДанныхКИспользованиюИзВыгрузки(ОбластьДанных, ИДФайлаВыгрузки, 
				СообщениеОбОшибке);
			
		Иначе
			
			РезультатПодготовки = ПодготовитьОбластьДанныхКИспользованиюИзЭталонной(ОбластьДанных, ИДФайлаВыгрузки, 
				Вариант, СообщениеОбОшибке);
				
		КонецЕсли;
		
		СменитьСтатусОбластиИУведомитьМенеджер(МенеджерЗаписи, РезультатПодготовки, СообщениеОбОшибке);

	Исключение
		РазблокироватьДанныеДляРедактирования(КлючОбласти);
		ВызватьИсключение;
	КонецПопытки;
	
	РазблокироватьДанныеДляРедактирования(КлючОбласти);

КонецПроцедуры

// Копирует данные области данных в другую область данных.
// 
// Параметры: 
//   ОбластьИсточник - Число - значение разделителя области данных источника данных.
//   ОбластьПриемник - Число - значение разделителя области данных приемника данных.
// 
Процедура СкопироватьДанныеОбласти(Знач ОбластьИсточник, Знач ОбластьПриемник) Экспорт
	
	Если НЕ Пользователи.ЭтоПолноправныйПользователь(, Истина) Тогда
		ВызватьИсключение(НСтр("ru = 'Недостаточно прав для выполнения операции'"));
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	УстановитьРазделениеСеанса(Истина, ОбластьИсточник);
	
	ИмяФайлаВыгрузки = Неопределено;
	
	Если Не ОбщегоНазначения.ПодсистемаСуществует("ТехнологияСервиса.ВыгрузкаЗагрузкаОбластейДанных") Тогда
		
		ВызватьИсключениеОтсутствуетПодсистемаБТС("ТехнологияСервиса.ВыгрузкаЗагрузкаОбластейДанных");
		
	КонецЕсли;
	
	МодульВыгрузкаЗагрузкаОбластейДанных = ОбщегоНазначения.ОбщийМодуль("ВыгрузкаЗагрузкаОбластейДанных");
	
	Попытка
		ИмяФайлаВыгрузки = МодульВыгрузкаЗагрузкаОбластейДанных.ВыгрузитьТекущуюОбластьДанныхВАрхив();
	Исключение
		ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииКопированиеОбластиДанных(), 
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		Если ИмяФайлаВыгрузки <> Неопределено Тогда
			Попытка
				УдалитьФайлы(ИмяФайлаВыгрузки);
			Исключение
				ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииКопированиеОбластиДанных(), 
					УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			КонецПопытки;
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;
	
	УстановитьРазделениеСеанса(Неопределено, ОбластьПриемник);
	
	Попытка
		МодульВыгрузкаЗагрузкаОбластейДанных.ЗагрузитьТекущуюОбластьДанныхИзАрхива(ИмяФайлаВыгрузки);
	Исключение
		ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииКопированиеОбластиДанных(), 
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		Попытка
			УдалитьФайлы(ИмяФайлаВыгрузки);
		Исключение
			ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииКопированиеОбластиДанных(), 
				УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		КонецПопытки;
		ВызватьИсключение;
	КонецПопытки;
	
	Попытка
		УдалитьФайлы(ИмяФайлаВыгрузки);
	Исключение
		ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииКопированиеОбластиДанных(), 
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
КонецПроцедуры

// Удаляет все данные области данных, кроме предопределенных, устанавливает для области данных
//  статус Удалена, отправляет в менеджер сервиса сообщение с информацией об изменении статуса
//  области. После этого область данных будет непригодна к использованию.
//
// Если нужно удалить все данные области без изменения ее статуса и с сохранением возможности
//  дальнейшего использования области, необходимо использовать процедуру ОчиститьДанныеОбласти().
//
// Параметры: 
//  ОбластьДанных - Число - значение разделителя области данных которую требуется очистить.
//   При вызове процедуры разделение данных уже должно быть переключено в эту область.
//  УдалитьПользователей - Булево - флаг необходимости удаления пользователей информационной
//    базы для данной области данных.
//
Процедура ОчиститьОбластьДанных(Знач ОбластьДанных, Знач УдалитьПользователей = Истина) Экспорт
	
	Если НЕ Пользователи.ЭтоПолноправныйПользователь(, Истина) Тогда
		ВызватьИсключение(НСтр("ru = 'Недостаточно прав для выполнения операции'"));
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	КлючОбласти = СоздатьКлючЗаписиРегистраСведенийВспомогательныхДанных(
		РегистрыСведений.ОбластиДанных,
		Новый Структура(РазделительВспомогательныхДанных(), ОбластьДанных));
	ЗаблокироватьДанныеДляРедактирования(КлючОбласти);
	
	Попытка
		
		МенеджерЗаписи = ПолучитьМенеджерЗаписиОбластиДанных(ОбластьДанных, Перечисления.СтатусыОбластейДанных.КУдалению);
		
		РаботаВМоделиСервисаПереопределяемый.ПриУдаленииОбластиДанных(ОбластьДанных);
		
		ОчиститьДанныеОбласти(УдалитьПользователей); // Вызываем очистку
		
		// Восстановление предопределенных элементов.
		МодельДанных = РаботаВМоделиСервисаПовтИсп.ПолучитьМодельДанныхОбласти();

		Для каждого ЭлементМодели Из МодельДанных Цикл
			
			ПолноеИмяОбъектаМетаданных = ЭлементМодели.Ключ;
			
			Если ЭтоПолноеИмяСправочника(ПолноеИмяОбъектаМетаданных)
				ИЛИ ЭтоПолноеИмяПланаСчетов(ПолноеИмяОбъектаМетаданных)
				ИЛИ ЭтоПолноеИмяПланаВидовХарактеристик(ПолноеИмяОбъектаМетаданных)
				ИЛИ ЭтоПолноеИмяПланаВидовРасчета(ПолноеИмяОбъектаМетаданных) Тогда
				
				ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(ПолноеИмяОбъектаМетаданных);
				
				Если ОбъектМетаданных.ПолучитьИменаПредопределенных().Количество() > 0 Тогда
					
					Менеджер = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ПолноеИмяОбъектаМетаданных);
					Менеджер.УстановитьИнициализациюПредопределенныхДанных(Ложь);
					
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЦикла;		

		СменитьСтатусОбластиИУведомитьМенеджер(МенеджерЗаписи, "ОбластьУдалена", "");
		
	Исключение
		РазблокироватьДанныеДляРедактирования(КлючОбласти);
		ВызватьИсключение;
	КонецПопытки;
	
	РазблокироватьДанныеДляРедактирования(КлючОбласти);
	
КонецПроцедуры

// Удаляет все разделенные данные из текущей области данных (в т.ч. при выключенном
//  разделении по областям данных), кроме переопределенных.
//
// Параметры:
//  УдалитьПользователей - Булево - флаг необходимости удаления пользователей информационной базы.
//
Процедура ОчиститьДанныеОбласти(Знач УдалитьПользователей) Экспорт
	
	МодельДанных = РаботаВМоделиСервисаПовтИсп.ПолучитьМодельДанныхОбласти();
	
	ИсключенияОчистки = Новый Массив();
	ИсключенияОчистки.Добавить(Метаданные.РегистрыСведений.ОбластиДанных.ПолноеИмя());
	
	Для каждого ЭлементМодели Из МодельДанных Цикл
		
		ПолноеИмяОбъектаМетаданных = ЭлементМодели.Ключ;
		ОписаниеОбъектаМетаданных = ЭлементМодели.Значение; // ОбъектМетаданных
		
		Если ИсключенияОчистки.Найти(ПолноеИмяОбъектаМетаданных) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Если ЭтоПолноеИмяКонстанты(ПолноеИмяОбъектаМетаданных) Тогда
			
			ОбъектМетаданныхОбласти = Метаданные.Константы.Найти(ОписаниеОбъектаМетаданных.Имя);
			МенеджерЗначения = Константы[ОписаниеОбъектаМетаданных.Имя].СоздатьМенеджерЗначения();
			МенеджерЗначения.ОбменДанными.Загрузка = Истина;
			МенеджерЗначения.ДополнительныеСвойства.Вставить("ОтключитьМеханизмРегистрацииОбъектов");
			МенеджерЗначения.Значение = ОбъектМетаданныхОбласти.Тип.ПривестиЗначение();
			МенеджерЗначения.Записать();
			
		ИначеЕсли ЭтоПолноеИмяОбъектаСсылочногоТипа(ПолноеИмяОбъектаМетаданных) Тогда
			
			ЭтоПланОбмена = ЭтоПолноеИмяПланаОбмена(ПолноеИмяОбъектаМетаданных);
			
			Запрос = Новый Запрос(
			"ВЫБРАТЬ
			|	Т.Ссылка КАК Ссылка
			|ИЗ
			|	" + ПолноеИмяОбъектаМетаданных + " КАК Т");
			
			Если ЭтоПланОбмена Тогда
				
				Запрос.Текст = Запрос.Текст + "
				|ГДЕ
				|	Т.Ссылка <> &ЭтотУзел";
				
				Запрос.УстановитьПараметр("ЭтотУзел", ПланыОбмена[ОписаниеОбъектаМетаданных.Имя].ЭтотУзел());
				
			КонецЕсли;
			
			РезультатЗапроса = Запрос.Выполнить();
			Выборка = РезультатЗапроса.Выбрать();
			
			Пока Выборка.Следующий() Цикл
				
				УдаляемыйОбъект = Выборка.Ссылка.ПолучитьОбъект();
				УдаляемыйОбъект.ОбменДанными.Загрузка = Истина;
				УдаляемыйОбъект.ДополнительныеСвойства.Вставить("ОтключитьМеханизмРегистрацииОбъектов");
				УдаляемыйОбъект.Удалить();
				
			КонецЦикла;
			
			
		ИначеЕсли ЭтоПолноеИмяРегистра(ПолноеИмяОбъектаМетаданных)
				ИЛИ ЭтоПолноеИмяПерерасчета(ПолноеИмяОбъектаМетаданных) 
				Или ЭтоПолноеИмяПоследовательности(ПолноеИмяОбъектаМетаданных) Тогда
			
			ЭтоРегистрНакопления = ЭтоПолноеИмяРегистраНакопления(ПолноеИмяОбъектаМетаданных);
			ЭтоРегистрБухгалтерии = ЭтоПолноеИмяРегистраБухгалтерии(ПолноеИмяОбъектаМетаданных);
			ЭтоРегистрСведений = ЭтоПолноеИмяРегистраСведений(ПолноеИмяОбъектаМетаданных);
			
			Менеджер = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ПолноеИмяОбъектаМетаданных); // РегистрНакопленияМенеджерИмяРегистраНакопления
			
			ЭтоНезависимыйРегистрСведений = Ложь;
			
			Если ЭтоРегистрНакопления Тогда
				
				РегистрМетаданные = Метаданные.РегистрыНакопления.Найти(ОписаниеОбъектаМетаданных.Имя);
				
				Если РегистрМетаданные.ВидРегистра = Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Остатки Тогда
					
					Если Менеджер.ПолучитьМинимальныйПериодРассчитанныхИтогов() <> '00010101'
						ИЛИ Менеджер.ПолучитьМаксимальныйПериодРассчитанныхИтогов() <> КонецМесяца('00010101') Тогда
					
						Менеджер.УстановитьМинимальныйИМаксимальныйПериодыРассчитанныхИтогов('00010101', '00010101');
						
					КонецЕсли;
					
					Если Менеджер.ПолучитьИспользованиеТекущихИтогов() Тогда
					
						Менеджер.УстановитьИспользованиеТекущихИтогов(Ложь);
						
					КонецЕсли;
					
					Если Менеджер.ПолучитьИспользованиеИтогов() Тогда
					
						Менеджер.УстановитьИспользованиеИтогов(Ложь);
						
					КонецЕсли;
					
				КонецЕсли;
				
			ИначеЕсли ЭтоРегистрБухгалтерии Тогда
				
				Если Менеджер.ПолучитьМинимальныйПериодРассчитанныхИтогов() <> '00010101'
					ИЛИ Менеджер.ПолучитьМаксимальныйПериодРассчитанныхИтогов() <> '00010101' Тогда
				
					Менеджер.УстановитьМинимальныйИМаксимальныйПериодыРассчитанныхИтогов('00010101', '00010101');
					
				КонецЕсли;
				
				Если Менеджер.ПолучитьИспользованиеТекущихИтогов() Тогда
				
					Менеджер.УстановитьИспользованиеТекущихИтогов(Ложь);
					
				КонецЕсли;
				
				Если Менеджер.ПолучитьИспользованиеИтогов() Тогда
				
					Менеджер.УстановитьИспользованиеИтогов(Ложь);
					
				КонецЕсли;
				
			ИначеЕсли ЭтоРегистрСведений Тогда
				
				РегистрМетаданные = Метаданные.РегистрыСведений.Найти(ОписаниеОбъектаМетаданных.Имя);
				
				Если РегистрМетаданные.РазрешитьИтогиСрезПервых
					ИЛИ РегистрМетаданные.РазрешитьИтогиСрезПоследних Тогда
				
					Если Менеджер.ПолучитьИспользованиеИтогов() Тогда
					
						Менеджер.УстановитьИспользованиеИтогов(Ложь);
						
					КонецЕсли;
					
				КонецЕсли;
				
				ЭтоНезависимыйРегистрСведений = (РегистрМетаданные.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.Независимый);
				
			КонецЕсли;
			
			Если ЭтоНезависимыйРегистрСведений Тогда
				
				НаборЗаписей = Менеджер.СоздатьНаборЗаписей();
				НаборЗаписей.ОбменДанными.Загрузка = Истина;
				НаборЗаписей.ДополнительныеСвойства.Вставить("ОтключитьМеханизмРегистрацииОбъектов");
				НаборЗаписей.Записать();
				
			Иначе
				
				ПараметрыВыборки = ПараметрыВыборки(ПолноеИмяОбъектаМетаданных);
				ИмяПоляРегистратор = ПараметрыВыборки.ИмяПоляРегистратор;
				
				Запрос = Новый Запрос(
				"ВЫБРАТЬ РАЗЛИЧНЫЕ
				|	Т.Регистратор КАК Регистратор
				|ИЗ
				|	" + ПараметрыВыборки.Таблица + " КАК Т");
				
				Если ИмяПоляРегистратор <> "Регистратор" Тогда
					
					Запрос.Текст = СтрЗаменить(Запрос.Текст, "Регистратор", ИмяПоляРегистратор);
					
				КонецЕсли;
				
				РезультатЗапроса = Запрос.Выполнить();
				Выборка = РезультатЗапроса.Выбрать();
				
				Пока Выборка.Следующий() Цикл
					
					НаборЗаписей = Менеджер.СоздатьНаборЗаписей();
					ОтборРегистратор = НаборЗаписей.Отбор[ИмяПоляРегистратор]; // ЭлементОтбора
					ОтборРегистратор.Установить(Выборка[ИмяПоляРегистратор]);
					НаборЗаписей.ОбменДанными.Загрузка = Истина;
					НаборЗаписей.ДополнительныеСвойства.Вставить("ОтключитьМеханизмРегистрацииОбъектов");
					НаборЗаписей.Записать();
					
				КонецЦикла;
				
			КонецЕсли;
			
		ИначеЕсли ЭтоПолноеИмяРегламентногоЗадания(ПолноеИмяОбъектаМетаданных) Тогда
			
			ОбъектМетаданныхОбласти = Метаданные.РегламентныеЗадания.Найти(ОписаниеОбъектаМетаданных.Имя);
			Для каждого РегламентноеЗадание Из РегламентныеЗадания.ПолучитьРегламентныеЗадания(Новый Структура("Метаданные", ОбъектМетаданныхОбласти)) Цикл
				Если РегламентноеЗадание.Предопределенное Тогда
					РегламентноеЗадание.Использование = Ложь;
					РегламентноеЗадание.Записать();
				Иначе
					РегламентноеЗадание.Удалить();
				КонецЕсли;
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЦикла;
	
	// Пользователи
	Если УдалитьПользователей Тогда
		
		ПервыйАдминистратор = Неопределено;
		
		Для каждого ПользовательИБ Из ПользователиИнформационнойБазы.ПолучитьПользователей() Цикл
			
			Если ПервыйАдминистратор = Неопределено И Пользователи.ЭтоПолноправныйПользователь(ПользовательИБ, Истина, Ложь) Тогда
				
				// Отложим удаление администратора, чтобы на момент его удаления все остальные
				// пользователи информационной базы уже были удалены.
				ПервыйАдминистратор = ПользовательИБ;
				
			Иначе
				
				ПользовательИБ.Удалить();
				
			КонецЕсли;
			
		КонецЦикла;
		
		Если ПервыйАдминистратор <> Неопределено Тогда
			
			ПервыйАдминистратор.Удалить();
			
		КонецЕсли;
		
	КонецЕсли;
	
	
	// Очистка истории.
	ИсторияРаботыПользователя.Очистить();
	
	// Настройки
	Хранилища = Новый Массив;
	Хранилища.Добавить(ХранилищеВариантовОтчетов);
	Хранилища.Добавить(ХранилищеНастроекДанныхФорм);
	Хранилища.Добавить(ХранилищеОбщихНастроек);
	Хранилища.Добавить(ХранилищеПользовательскихНастроекОтчетов);
	Хранилища.Добавить(ХранилищеСистемныхНастроек);
	Хранилища.Добавить(ХранилищеПользовательскихНастроекДинамическихСписков);
	
	Для каждого Хранилище Из Хранилища Цикл
		
		Если ТипЗнч(Хранилище) <> Тип("СтандартноеХранилищеНастроекМенеджер") Тогда
			
			// Настройки будут удалены при очистке данных.
			Продолжить;
			
		КонецЕсли;
		
		Хранилище.Удалить(Неопределено, Неопределено, Неопределено);
		
	КонецЦикла;
	
КонецПроцедуры

// Процедура одноименного регламентного задания.
// Находит все области данных со статусами, требующими обработки
// прикладным приложением, и при необходимости планирует запуск ФЗ
// по их обслуживанию.
// 
Процедура ОбслуживаниеОбластейДанных() Экспорт
	
	Если НЕ РазделениеВключено() Тогда
		Возврат;
	КонецЕсли;
	
	ОбщегоНазначения.ПриНачалеВыполненияРегламентногоЗадания(Метаданные.РегламентныеЗадания.ОбслуживаниеОбластейДанных);
	
	МаксимальноеКоличествоПовторов = 3;
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ОбластиДанных.ОбластьДанныхВспомогательныеДанные КАК ОбластьДанных,
	|	ОбластиДанных.Статус КАК Статус,
	|	ОбластиДанных.ИдентификаторВыгрузки КАК ИдентификаторВыгрузки,
	|	ОбластиДанных.Вариант КАК Вариант
	|ИЗ
	|	РегистрСведений.ОбластиДанных КАК ОбластиДанных
	|ГДЕ
	|	ОбластиДанных.Статус В (ЗНАЧЕНИЕ(Перечисление.СтатусыОбластейДанных.Новая), ЗНАЧЕНИЕ(Перечисление.СтатусыОбластейДанных.КУдалению))
	|	И ОбластиДанных.ОшибкаОбработки = ЛОЖЬ
	|
	|УПОРЯДОЧИТЬ ПО
	|	ОбластьДанных";
	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();
	
	Пока Выборка.Следующий() Цикл
		
		Ключ = СоздатьКлючЗаписиРегистраСведенийВспомогательныхДанных(
			РегистрыСведений.ОбластиДанных,
			Новый Структура(РазделительВспомогательныхДанных(), Выборка.ОбластьДанных));
		
		Попытка
			ЗаблокироватьДанныеДляРедактирования(Ключ);
		Исключение
			Продолжить;
		КонецПопытки;
		
		Менеджер = РегистрыСведений.ОбластиДанных.СоздатьМенеджерЗаписи();
		Менеджер.ОбластьДанныхВспомогательныеДанные = Выборка.ОбластьДанных;
		Менеджер.Прочитать();
		
		Если Менеджер.Статус = Перечисления.СтатусыОбластейДанных.Новая Тогда 
			ИмяМетода = "РаботаВМоделиСервиса.ПодготовитьОбластьДанныхКИспользованию";
		ИначеЕсли Менеджер.Статус = Перечисления.СтатусыОбластейДанных.КУдалению Тогда 
			ИмяМетода = "РаботаВМоделиСервиса.ОчиститьОбластьДанных";
		Иначе
			РазблокироватьДанныеДляРедактирования(Ключ);
			Продолжить;
		КонецЕсли;
		
		Если Менеджер.Повтор < МаксимальноеКоличествоПовторов Тогда
		
			ОтборЗадания = Новый Структура;
			ОтборЗадания.Вставить("ИмяМетода", ИмяМетода);
			ОтборЗадания.Вставить("Ключ"     , "1");
			ОтборЗадания.Вставить("ОбластьДанных", Выборка.ОбластьДанных);
			Задания = ОчередьЗаданий.ПолучитьЗадания(ОтборЗадания);
			Если Задания.Количество() > 0 Тогда
				РазблокироватьДанныеДляРедактирования(Ключ);
				Продолжить;
			КонецЕсли;
			
			Менеджер.Повтор = Менеджер.Повтор + 1;
			
			КопияМенеджера = РегистрыСведений.ОбластиДанных.СоздатьМенеджерЗаписи();
			ЗаполнитьЗначенияСвойств(КопияМенеджера, Менеджер);
			Менеджер = КопияМенеджера;
			
			Менеджер.Записать();

			ПараметрыМетода = Новый Массив;
			ПараметрыМетода.Добавить(Выборка.ОбластьДанных);
			
			Если Выборка.Статус = Перечисления.СтатусыОбластейДанных.Новая Тогда
				
				ПараметрыМетода.Добавить(Выборка.ИдентификаторВыгрузки);
				Если ЗначениеЗаполнено(Выборка.Вариант) Тогда
					ПараметрыМетода.Добавить(Выборка.Вариант);
				КонецЕсли;
			КонецЕсли;
			
			ПараметрыЗадания = Новый Структура;
			ПараметрыЗадания.Вставить("ИмяМетода"    , ИмяМетода);
			ПараметрыЗадания.Вставить("Параметры"    , ПараметрыМетода);
			ПараметрыЗадания.Вставить("Ключ"         , "1");
			ПараметрыЗадания.Вставить("ОбластьДанных", Выборка.ОбластьДанных);
			ПараметрыЗадания.Вставить("ЭксклюзивноеВыполнение", Истина);
						
			ОчередьЗаданий.ДобавитьЗадание(ПараметрыЗадания);
			
			РазблокироватьДанныеДляРедактирования(Ключ);
		Иначе
			
			СменитьСтатусОбластиИУведомитьМенеджер(Менеджер, ?(Менеджер.Статус = Перечисления.СтатусыОбластейДанных.Новая,
				"ФатальнаяОшибка", "ОшибкаУдаления"), НСтр("ru = 'Исчерпано количество попыток обработки области'"));
			
			РазблокироватьДанныеДляРедактирования(Ключ);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Возвращает прокси web-сервиса для синхронизации административных действий в сервисе.
// 
// Параметры:
//  ПарольПользователя - Строка - пароль для подключения.
// 
// Возвращаемое значение: 
//   WSПрокси - прокси менеджера сервиса. 
// 
Функция ПолучитьПроксиМенеджераСервиса(Знач ПарольПользователя = Неопределено) Экспорт
	
	АдресМенеджераСервиса = ВнутреннийАдресМенеджераСервиса();
	Если Не ЗначениеЗаполнено(АдресМенеджераСервиса) Тогда
		ВызватьИсключение(НСтр("ru = 'Не установлены параметры связи с менеджером сервиса.'"));
	КонецЕсли;
	
	АдресСервиса = АдресМенеджераСервиса + "/ws/ManageApplication_1_0_3_1?wsdl";
	
	Если ПарольПользователя = Неопределено Тогда
		ИмяПользователя = ИмяСлужебногоПользователяМенеджераСервиса();
		ПарольПользователя = ПарольСлужебногоПользователяМенеджераСервиса();
	Иначе
		ИмяПользователя = ИмяПользователя();
	КонецЕсли;
	
	ПараметрыПодключения = ОбщегоНазначения.ПараметрыПодключенияWSПрокси();
	ПараметрыПодключения.АдресWSDL = АдресСервиса;
	ПараметрыПодключения.URIПространстваИмен = "http://www.1c.ru/SaaS/ManageApplication/1.0.3.1";
	ПараметрыПодключения.ИмяСервиса = "ManageApplication_1_0_3_1";
	ПараметрыПодключения.ИмяПользователя = ИмяПользователя;
	ПараметрыПодключения.Пароль = ПарольПользователя;
	ПараметрыПодключения.Таймаут = 20;
	Прокси = ОбщегоНазначения.СоздатьWSПрокси(ПараметрыПодключения);
	
	Возврат Прокси;
	
КонецФункции

// Устанавливает разделение сеанса.
//
// Параметры:
//  Использование - Булево - использование разделителя ОбластьДанных в сеансе.
//  ОбластьДанных - Число - значение разделителя ОбластьДанных.
//
Процедура УстановитьРазделениеСеанса(Знач Использование = Неопределено, Знач ОбластьДанных = Неопределено) Экспорт
	
	Если Не СеансЗапущенБезРазделителей() Тогда
		ВызватьИсключение(НСтр("ru = 'Изменить разделение сеанса возможно только из сеанса запущенного без указания разделителей'"));
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если ОбластьДанных <> Неопределено Тогда
		Если ПараметрыСеанса.ОбластьДанныхИспользование Тогда
			// При включенном использовании нужно выйти из области, 
			// чтобы при неудачном входе в область, ошибка в ЖР записалась в неразделенном сеансе.
			ПараметрыСеанса.ОбластьДанныхИспользование = Ложь;
			ПриИзмененииОбластиДанных();
			ПараметрыСеанса.ОбластьДанныхЗначение = ОбластьДанных;
			ПараметрыСеанса.ОбластьДанныхИспользование = Истина;
		Иначе
			ПараметрыСеанса.ОбластьДанныхЗначение = ОбластьДанных;
		КонецЕсли;
	КонецЕсли;
	
	Если Использование <> Неопределено Тогда
		ПараметрыСеанса.ОбластьДанныхИспользование = Использование;
	КонецЕсли;
	
	ПриИзмененииОбластиДанных();
	
КонецПроцедуры

// Возвращает значение разделителя текущей области данных.
// В случае если значение не установлено, выдается ошибка.
// 
// Возвращаемое значение: 
//   Число - значение разделителя текущей области данных. 
// 
Функция ЗначениеРазделителяСеанса() Экспорт
	
	Если НЕ РазделениеВключено() Тогда
		Возврат 0;
	Иначе
		Если Не ИспользованиеРазделителяСеанса() Тогда
			ВызватьИсключение(НСтр("ru = 'Не установлено значение разделителя'"));
		КонецЕсли;
		
		// Получим значение разделителя текущей области данных.
		Возврат ПараметрыСеанса.ОбластьДанныхЗначение;
	КонецЕсли;
	
КонецФункции

// Возвращает флаг использования разделителя ОбластьДанных для текущего сеанса.
//
// Возвращаемое значение: 
//  Булево - если Истина, разделение используется, иначе нет.
//
Функция ИспользованиеРазделителяСеанса() Экспорт
	
	Возврат ПараметрыСеанса.ОбластьДанныхИспользование;
	
КонецФункции

// Добавляет описание параметра по имени константы в таблицу параметров.
// Возвращает добавленный параметр.
//
// Параметры: 
//   ТаблицаПараметров - см. ПараметрыИБ
//   ИмяКонстанты - Строка - имя константы, которую необходимо добавить в параметры ИБ.
//
// Возвращаемое значение: 
//   СтрокаТаблицыЗначений - описание добавленного параметра.
// 
Функция ДобавитьКонстантуВТаблицуПараметровИБ(Знач ТаблицаПараметров, Знач ИмяКонстанты) Экспорт
	
	МетаданныеКонстанты = Метаданные.Константы[ИмяКонстанты]; // ОбъектМетаданныхКонстанта
	
	СтрокаПараметра = ТаблицаПараметров.Добавить();
	СтрокаПараметра.Имя = МетаданныеКонстанты.Имя;
	СтрокаПараметра.Описание = МетаданныеКонстанты.Представление();
	СтрокаПараметра.Тип = МетаданныеКонстанты.Тип;
	
	Возврат СтрокаПараметра;
	
КонецФункции

// Получает имя приложения - так, как его задал абонент.
//
// Возвращаемое значение:
//   Строка - имя приложения.
//
Функция ПолучитьИмяПриложения() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	Возврат Константы.ПредставлениеОбластиДанных.Получить();
	
КонецФункции

// Возвращает размер блоков в Мб для передачи больших файлов частями.
//
// Возвращаемое значение:
//   Число - размер блока передачи файлов в мегабайтах.
//
Функция ПолучитьРазмерБлокаПередачиФайла() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	РазмерБлокаПередачиФайла = Константы.РазмерБлокаПередачиФайла.Получить(); // Мб
	Если Не ЗначениеЗаполнено(РазмерБлокаПередачиФайла) Тогда
		РазмерБлокаПередачиФайла = 20;
	КонецЕсли;
	Возврат РазмерБлокаПередачиФайла;

КонецФункции

// Сериализует объект структурного типа.
//
// Параметры:
//   ЗначениеСтруктурногоТипа - Массив, Структура, Соответствие - сериализуемый объект.
//
// Возвращаемое значение:
//   Строка - сериализованное значение объекта структурного типа.
//
Функция ЗаписатьСтруктурныйОбъектXDTOВСтроку(Знач ЗначениеСтруктурногоТипа) Экспорт
	
	ОбъектXDTO = СтруктурныйОбъектВОбъектXDTO(ЗначениеСтруктурногоТипа);
	
	Возврат ЗаписатьЗначениеВСтроку(ОбъектXDTO);
	
КонецФункции

// Кодирует строковое значение по алгоритму base64.
//
// Параметры:
//   Строка - Строка - исходная строка, которую необходимо закодировать.
//
// Возвращаемое значение:
//   Строка - закодированная строка.
//
Функция СтрокаВBase64(Знач Строка) Экспорт
	
	Хранилище = Новый ХранилищеЗначения(Строка, Новый СжатиеДанных(9));
	
	Возврат XMLСтрока(Хранилище);
	
КонецФункции

// Декодирует base64-представление строки в исходное значение.
//
// Параметры:
//   СтрокаBase64 - Строка - исходная строка, которую необходимо декодировать.
//
// Возвращаемое значение:
//   Строка - декодированная строка.
//
Функция Base64ВСтроку(Знач СтрокаBase64) Экспорт
	
	Хранилище = XMLЗначение(Тип("ХранилищеЗначения"), СтрокаBase64);
	
	Возврат Хранилище.Получить();
	
КонецФункции

// Возвращает часовой пояс области данных.
// Предназначена для вызова из сеансов с неустановленным использованием
// разделителей. В сеансах с установленным использованием разделителей
// следует использовать ПолучитьЧасовойПоясИнформационнойБазы().
//
// Параметры:
//  ОбластьДанных - Число - значение разделителя области данных, часовой
//   пояс которой требуется получить.
//
// Возвращаемое значение:
//  Строка, Неопределено - часовой пояс области данных, Неопределено,
//   если часовой пояс не задан.
//
Функция ПолучитьЧасовойПоясОбластиДанных(Знач ОбластьДанных) Экспорт
	
	Менеджер = Константы.ЧасовойПоясОбластиДанных.СоздатьМенеджерЗначения();
	Менеджер.ОбластьДанныхВспомогательныеДанные = ОбластьДанных;
	Менеджер.Прочитать();
	ЧасовойПояс = Менеджер.Значение;
	
	Если Не ЗначениеЗаполнено(ЧасовойПояс) Тогда
		ЧасовойПояс = Неопределено;
	КонецЕсли;
	
	Возврат ЧасовойПояс;
	
КонецФункции

// Возвращает внутренний адрес менеджера сервиса.
//
// Возвращаемое значение:
//  Строка - внутренний адрес менеджера сервиса.
//
Функция ВнутреннийАдресМенеджераСервиса() Экспорт
	
	Возврат РаботаВМоделиСервисаБТС.ВнутреннийАдресМенеджераСервиса();
	
КонецФункции

// Возвращает имя служебного пользователя менеджера сервиса.
//
// Возвращаемое значение:
//  Строка - имя служебного пользователя менеджера сервиса.
//
Функция ИмяСлужебногоПользователяМенеджераСервиса() Экспорт
	
	Возврат РаботаВМоделиСервисаБТС.ИмяСлужебногоПользователяМенеджераСервиса();
	
КонецФункции

// Возвращает пароль служебного пользователя менеджера сервиса.
//
// Возвращаемое значение:
//  Строка - пароль служебного пользователя менеджера сервиса.
//
Функция ПарольСлужебногоПользователяМенеджераСервиса() Экспорт
	
	Возврат РаботаВМоделиСервисаБТС.ПарольСлужебногоПользователяМенеджераСервиса();
	
КонецФункции

// Обрабатывает информацию об ошибке, полученную из web-сервиса.
// В случае если передана не пустая информация об ошибке, записывает
// подробное представление ошибки в журнал регистрации и вызывает
// исключение с текстом краткого представления об ошибке.
//
// Параметры:
//   ИнформацияОбОшибке - ИнформацияОбОшибке - информация об ошибке,
//   ИмяПодсистемы - Строка - имя подсистемы,
//   ИмяВебСервиса - Строка - имя web-сервиса,
//   ИмяОперации - Строка - имя операции.
//
Процедура ОбработатьИнформациюОбОшибкеWebСервиса(Знач ИнформацияОбОшибке, Знач ИмяПодсистемы = "", Знач ИмяВебСервиса = "", Знач ИмяОперации = "") Экспорт
	
	Если ИнформацияОбОшибке = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если ПустаяСтрока(ИмяПодсистемы) Тогда
		ИмяПодсистемы = Метаданные.Подсистемы.ТехнологияСервиса.Имя;
	КонецЕсли;
	
	ИмяСобытия = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = '%1.Ошибка вызова операции web-сервиса'", ОбщегоНазначения.КодОсновногоЯзыка()),
		ИмяПодсистемы);
	
	ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Ошибка при вызове операции %1 веб-сервиса %2: %3'", ОбщегоНазначения.КодОсновногоЯзыка()),
		ИмяОперации,
		ИмяВебСервиса,
		ИнформацияОбОшибке.DetailErrorDescription);
	
	ЗаписьЖурналаРегистрации(
		ИмяСобытия,
		УровеньЖурналаРегистрации.Ошибка,
		,
		,
		ТекстОшибки);
		
	ВызватьИсключение ИнформацияОбОшибке.BriefErrorDescription;
	
КонецПроцедуры

// Возвращает псевдоним пользователя, который должен использоваться в интерфейсе.
//
// Параметры:
//   ИдентификаторПользователя - УникальныйИдентификатор - идентификатор пользователя.
//
// Возвращаемое значение:
//   Строка - псевдоним пользователя информационной базы для отображения в интерфейсе.
//
Функция ПсевдонимПользователяИнформационнойБазы(Знач ИдентификаторПользователя) Экспорт
	
	Псевдоним = "";
	
	ИнтеграцияПодсистемБТС.ПриОпределенииПсевдонимаПользователя(ИдентификаторПользователя, Псевдоним);
	Возврат Псевдоним;
	
КонецФункции

// Получает в транзакции менеджер записи для регистра ОбластиДанных.
//
// Параметры:
//  ОбластьДанных - Число - номер области данных.
//  Статус - ПеречислениеСсылка.СтатусыОбластейДанных - ожидаемый статус области.
//
// Возвращаемое значение:
//  РегистрСведенийМенеджерЗаписи.ОбластиДанных - менеджер записи области данных.
//
Функция ПолучитьМенеджерЗаписиОбластиДанных(Знач ОбластьДанных, Знач Статус) Экспорт
	
	НачатьТранзакцию();
	Попытка
		Блокировка = Новый БлокировкаДанных;
		Элемент = Блокировка.Добавить("РегистрСведений.ОбластиДанных");
		Элемент.УстановитьЗначение("ОбластьДанныхВспомогательныеДанные", ОбластьДанных);
		Элемент.Режим = РежимБлокировкиДанных.Разделяемый;
		Блокировка.Заблокировать();
		
		МенеджерЗаписи = РегистрыСведений.ОбластиДанных.СоздатьМенеджерЗаписи();
		МенеджерЗаписи.ОбластьДанныхВспомогательныеДанные = ОбластьДанных;
		МенеджерЗаписи.Прочитать();
		
		Если НЕ МенеджерЗаписи.Выбран() Тогда
			ШаблонСообщения = НСтр("ru = 'Область данных %1 не найдена'");
			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, ОбластьДанных);
			ВызватьИсключение(ТекстСообщения);
		ИначеЕсли МенеджерЗаписи.Статус <> Статус Тогда
			ШаблонСообщения = НСтр("ru = 'Статус области данных %1 не равен ""%2""'");
			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, ОбластьДанных, Статус);
			ВызватьИсключение(ТекстСообщения);
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииПодготовкаОбластиДанных(), 
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение;
	КонецПопытки;
	
	Возврат МенеджерЗаписи;
	
КонецФункции

// Загружает данные в "типовую" область.
// 
// Параметры: 
//   ОбластьДанных - Число - номер заполняемой области.
//   ИДФайлаВыгрузки - УникальныйИдентификатор - ид файла начальных данных.
//   Вариант - Строка - вариант начальных данных.
//   СообщениеОбОшибке - Строка - возвращаемая, описание ошибки.
//
// Возвращаемое значение:
//  Строка - один из вариантов "Успех", "ФатальнаяОшибка".
//
Функция ПодготовитьОбластьДанныхКИспользованиюИзЭталонной(Знач ОбластьДанных, Знач ИДФайлаВыгрузки, 
												 		  Знач Вариант, СообщениеОбОшибке) Экспорт
	
	Если Константы.КопироватьОбластиДанныхИзЭталонной.Получить() Тогда
		
		Результат = ЗагрузитьОбластьИзПоставляемыхДанных(ОбластьДанных, ИДФайлаВыгрузки, Вариант, СообщениеОбОшибке);
		Если Результат <> "Успех" Тогда
			Возврат Результат;
		КонецЕсли;
		
	Иначе
		
		Результат = "Успех";
		
	КонецЕсли;
	
	ОбновлениеИнформационнойБазы.ВыполнитьОбновлениеИнформационнойБазы();
	
	Возврат Результат;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Контроль неразделенных данных.

// Обработчик подписки на событие КонтрольНеразделенныхОбъектовПриЗаписи.
//
Процедура КонтрольНеразделенныхОбъектовПриЗаписи(Источник, Отказ) Экспорт
	
	// ОбменДанными.Загрузка не требуется.
	// Запись неразделенных данных из разделенного сеанса запрещена.
	КонтрольНеразделенныхДанныхПриЗаписи(Источник);
	
КонецПроцедуры

// Обработчик подписки на событие КонтрольНеразделенныхНаборовЗаписейПриЗаписи.
//
Процедура КонтрольНеразделенныхНаборовЗаписейПриЗаписи(Источник, Отказ, Замещение) Экспорт
	
	// ОбменДанными.Загрузка не требуется.
	// Запись неразделенных данных из разделенного сеанса запрещена.
	КонтрольНеразделенныхДанныхПриЗаписи(Источник);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Работа с файлами

// Возвращает полное имя файла, полученного из файлового хранилища МС по его идентификатору.
//
// Параметры:
//   ИДФайла - УникальныйИдентификатор - идентификатор файла в файловом хранилище МС.
//
// Возвращаемое значение:
//   Строка - полное имя извлеченного файла.
//
Функция ПолучитьФайлИзХранилищаМенеджераСервиса(Знач ИДФайла) Экспорт
	
	ОписаниеФайла = Неопределено;
	
	АдресМенеджераСервиса = ВнутреннийАдресМенеджераСервиса();
	
	Если НЕ ЗначениеЗаполнено(АдресМенеджераСервиса) Тогда
		
		ВызватьИсключение(НСтр("ru = 'Не установлены параметры связи с менеджером сервиса.'"));
		
	КонецЕсли;
	
	ПараметрыДоступаКХранилищу = Новый Структура;
	ПараметрыДоступаКХранилищу.Вставить("URL", АдресМенеджераСервиса);
	ПараметрыДоступаКХранилищу.Вставить("UserName", ИмяСлужебногоПользователяМенеджераСервиса());
	ПараметрыДоступаКХранилищу.Вставить("Password", ПарольСлужебногоПользователяМенеджераСервиса());
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ТехнологияСервиса.ПередачаДанных") Тогда
		
		ПоддерживаемыеВерсии = ОбщегоНазначения.ПолучитьВерсииИнтерфейса(ПараметрыДоступаКХранилищу, "DataTransfer");
		
		Если ПоддерживаемыеВерсии.Количество() > 0 Тогда
			
			МодульПередачаДанных = ОбщегоНазначения.ОбщийМодуль("ПередачаДанныхСервер");
			ОписаниеФайла = МодульПередачаДанных.ПолучитьИзЛогическогоХранилища(ПараметрыДоступаКХранилищу, "files", ИДФайла);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Если ОписаниеФайла = Неопределено Тогда
		
		ОписаниеФайла = ПолучитьФайлИзХранилища(ИДФайла, ПараметрыДоступаКХранилищу, Истина, Истина);
		
	КонецЕсли;
	
	Если ОписаниеФайла = Неопределено Тогда
		
		Возврат Неопределено;
		
	КонецЕсли;
	
	СвойстваФайла = Новый Файл(ОписаниеФайла.ПолноеИмя);
	
	Если Не СвойстваФайла.Существует() Тогда
		
		Возврат Неопределено;
		
	КонецЕсли;
	
	// Менеджер сервиса устанавливает исходному файлу атрибут "Только чтение".
	// Унаследованный атрибут снимается, чтобы файл можно было удалить.
	СвойстваФайла.УстановитьТолькоЧтение(Ложь);	
	
	Возврат СвойстваФайла.ПолноеИмя;
	
КонецФункции

// Добавляет файл в хранилище менеджера сервиса.
//
// Параметры:
//   АдресДанныеФайл - Строка - адрес файла во временном хранилище,
//                   - ДвоичныеДанные - двоичные данные файла,
//                   - Файл - файл.
//   ИмяФайла - Строка - хранимое имя файла.
//   ДополнительныеПараметры - Структура - сериализуемыt в json данные.
//		
// Возвращаемое значение:
//   УникальныйИдентификатор - идентификатор файла в хранилище.
//
Функция ПоместитьФайлВХранилищеМенеджераСервиса(Знач АдресДанныеФайл, Знач ИмяФайла = "", ДополнительныеПараметры = Неопределено) Экспорт
	
	ИдентификаторФайлаВХранилище = Неопределено;
	
	ПараметрыДоступаКХранилищу = Новый Структура;
	ПараметрыДоступаКХранилищу.Вставить("URL", ВнутреннийАдресМенеджераСервиса());
	ПараметрыДоступаКХранилищу.Вставить("UserName", ИмяСлужебногоПользователяМенеджераСервиса());
	ПараметрыДоступаКХранилищу.Вставить("Password", ПарольСлужебногоПользователяМенеджераСервиса());
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ТехнологияСервиса.ПередачаДанных") Тогда
		
		ПоддерживаемыеВерсии = ОбщегоНазначения.ПолучитьВерсииИнтерфейса(ПараметрыДоступаКХранилищу, "DataTransfer");
		
		Если ПоддерживаемыеВерсии.Количество() > 0 Тогда
			
			МодульПередачаДанных = ОбщегоНазначения.ОбщийМодуль("ПередачаДанныхСервер");
			ИдентификаторФайлаВХранилище = МодульПередачаДанных.ОтправитьВЛогическоеХранилище(ПараметрыДоступаКХранилищу, 
				"files", 
				АдресДанныеФайл, 
				ИмяФайла, 
				ДополнительныеПараметры);
			
		КонецЕсли;
		
	КонецЕсли;
		
	Если ЗначениеЗаполнено(ИдентификаторФайлаВХранилище) Тогда
		
		Возврат ИдентификаторФайлаВХранилище;
		
	Иначе
		
		Возврат ПоместитьФайлВХранилище(АдресДанныеФайл, ПараметрыДоступаКХранилищу, ИмяФайла);
		
	КонецЕсли;

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Функции определения типов объектов метаданных по полному имени объекта
// метаданных.

// Ссылочные типы данных

// Определяет принадлежность объекта метаданных к общему типу "Документ" по полному имени
//  объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево - Истина, если документ.
//
Функция ЭтоПолноеИмяДокумента(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "Документ", "Document");
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Справочник" по полному имени
//  объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево - Истина, если справочник.
//
Функция ЭтоПолноеИмяСправочника(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "Справочник", "Catalog");
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Перечисление" по полному имени
//  объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево - Истина, если перечисление.
//
Функция ЭтоПолноеИмяПеречисления(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "Перечисление", "Enum");
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План обмена" по полному имени
//  объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево - Истина, если план обмена.
//
Функция ЭтоПолноеИмяПланаОбмена(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "ПланОбмена", "ExchangePlan");
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План видов характеристик" по
//  полному имени объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево - Истина если план видов характеристик.
//
Функция ЭтоПолноеИмяПланаВидовХарактеристик(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "ПланВидовХарактеристик", "ChartOfCharacteristicTypes");
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Бизнес-процесс" по полному имени
//  объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево - Истина, если бизнес-процесс.
//
Функция ЭтоПолноеИмяБизнесПроцесса(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "БизнесПроцесс", "BusinessProcess");
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Задача" по полному имени объекта
//  метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
// 
// Возвращаемое значение:
//  Булево - Истина, если задача.
//
Функция ЭтоПолноеИмяЗадачи(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "Задача", "Task");
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План счетов" по полному имени объекта
//  метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево - Истина, если план счетов.
//
Функция ЭтоПолноеИмяПланаСчетов(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "ПланСчетов", "ChartOfAccounts");
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "План видов расчета" по полному имени
//  объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево - Истина, если план видов расчета.
//
Функция ЭтоПолноеИмяПланаВидовРасчета(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "ПланВидовРасчета", "ChartOfCalculationTypes");
	
КонецФункции

// Регистры

// Определяет принадлежность объекта метаданных к общему типу "Регистр сведений" по полному имени
//  объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево - Истина если регистр сведений.
//
Функция ЭтоПолноеИмяРегистраСведений(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "РегистрСведений", "InformationRegister");
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Регистр накопления" по полному имени
//  объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево - Истина, если регистр накопления.
//
Функция ЭтоПолноеИмяРегистраНакопления(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "РегистрНакопления", "AccumulationRegister");
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Регистр бухгалтерии" по полному имени
//  объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево - Истина, если регистр бухгалтерии.
//
Функция ЭтоПолноеИмяРегистраБухгалтерии(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "РегистрБухгалтерии", "AccountingRegister");
	
КонецФункции

// Определяет принадлежность объекта метаданных к общему типу "Регистр расчета" по полному имени
//  объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево - Истина, если регистр расчета.
//
Функция ЭтоПолноеИмяРегистраРасчета(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "РегистрРасчета", "CalculationRegister")
		И Не ЭтоПолноеИмяПерерасчета(ПолноеИмя);
	
КонецФункции

// Перерасчеты

// Определяет принадлежность объекта метаданных к типу "Перерасчет" по полному имени
//  объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево - Истина если перерасчет.
//
Функция ЭтоПолноеИмяПерерасчета(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "Перерасчет", "Recalculation", 2);
	
КонецФункции

// Константы

// Определяет принадлежность объекта метаданных к общему типу "Константа" по полному имени
//  объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево - Истина, если константа.
//
Функция ЭтоПолноеИмяКонстанты(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "Константа", "Constant");
	
КонецФункции

// Журналы документов

// Определяет принадлежность объекта метаданных к общему типу "Журнал документов" по полному имени
//  объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево - Истина, если журнал документов.
//
Функция ЭтоПолноеИмяЖурналаДокументов(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "ЖурналДокументов", "DocumentJournal");
	
КонецФункции

// Последовательности

// Определяет принадлежность объекта метаданных к общему типу "Последовательности" по полному имени
//  объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево - Истина, если последовательность.
//
Функция ЭтоПолноеИмяПоследовательности(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "Последовательность", "Sequence");
	
КонецФункции

// РегламентныеЗадания

// Определяет принадлежность объекта метаданных к общему типу "Регламентные задания" по полному имени
//  объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево - Истина, если регламентное задание.
//
Функция ЭтоПолноеИмяРегламентногоЗадания(Знач ПолноеИмя) Экспорт
	
	Возврат ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(ПолноеИмя, "РегламентноеЗадание", "ScheduledJob");
	
КонецФункции

// Общие

// Определяет принадлежность объекта метаданных к типу регистр по полному имени объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево - Истина, если регистр.
//
Функция ЭтоПолноеИмяРегистра(Знач ПолноеИмя) Экспорт
	
	Возврат ЭтоПолноеИмяРегистраСведений(ПолноеИмя)
		ИЛИ ЭтоПолноеИмяРегистраНакопления(ПолноеИмя)
		ИЛИ ЭтоПолноеИмяРегистраБухгалтерии(ПолноеИмя)
		ИЛИ ЭтоПолноеИмяРегистраРасчета(ПолноеИмя);
	
КонецФункции

// Определяет принадлежность объекта метаданных к ссылочному типу по полному имени объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных, для которого необходимо определить
//   принадлежность к заданному типу.
//
// Возвращаемое значение:
//  Булево - Истина, если ссылочный тип.
//
Функция ЭтоПолноеИмяОбъектаСсылочногоТипа(Знач ПолноеИмя) Экспорт
	
	Возврат ЭтоПолноеИмяСправочника(ПолноеИмя)
		ИЛИ ЭтоПолноеИмяДокумента(ПолноеИмя)
		ИЛИ ЭтоПолноеИмяБизнесПроцесса(ПолноеИмя)
		ИЛИ ЭтоПолноеИмяЗадачи(ПолноеИмя)
		ИЛИ ЭтоПолноеИмяПланаСчетов(ПолноеИмя)
		ИЛИ ЭтоПолноеИмяПланаОбмена(ПолноеИмя)
		ИЛИ ЭтоПолноеИмяПланаВидовХарактеристик(ПолноеИмя)
		ИЛИ ЭтоПолноеИмяПланаВидовРасчета(ПолноеИмя);
	
КонецФункции

// Параметры выборки по полному имени объекта метаданных.
//
// Параметры:
//   ПолноеИмяОбъектаМетаданных - Строка - полное имя объекта метаданных.
//
// Возвращаемое значение:
//   Структура - параметры выборки.
//
Функция ПараметрыВыборки(Знач ПолноеИмяОбъектаМетаданных) Экспорт
	
	Результат = Новый Структура("Таблица,ИмяПоляРегистратор");
	
	Если ЭтоПолноеИмяРегистра(ПолноеИмяОбъектаМетаданных)
			ИЛИ ЭтоПолноеИмяПоследовательности(ПолноеИмяОбъектаМетаданных) Тогда
		
		Результат.Таблица = ПолноеИмяОбъектаМетаданных;
		Результат.ИмяПоляРегистратор = "Регистратор";
		
	ИначеЕсли ЭтоПолноеИмяПерерасчета(ПолноеИмяОбъектаМетаданных) Тогда
		
		Подстроки = СтрРазделить(ПолноеИмяОбъектаМетаданных, ".");
		Результат.Таблица = Подстроки[0] + "." + Подстроки[1] + "." + Подстроки[3];
		Результат.ИмяПоляРегистратор = "ОбъектПерерасчета";
		
	Иначе
		
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Функция ПараметрыВыборки() не должна использоваться для объекта %1.'"),
			ПолноеИмяОбъектаМетаданных);
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Имя события журнала регистрации для записи ошибок копирования области данных.
//
// Возвращаемое значение:
//  Строка - имя события ошибки.
//
Функция СобытиеЖурналаРегистрацииКопированиеОбластиДанных() Экспорт
	
	Возврат НСтр("ru = 'Работа в модели сервиса.Копирование области данных'", ОбщегоНазначения.КодОсновногоЯзыка());
	
КонецФункции

// Имя события журнала регистрации для записи ошибок блокировки области данных.
//
// Возвращаемое значение:
//  Строка - имя события ошибки.
//
Функция СобытиеЖурналаРегистрацииБлокировкаОбластиДанных() Экспорт
	
	Возврат НСтр("ru = 'Работа в модели сервиса.Блокировка области данных'", ОбщегоНазначения.КодОсновногоЯзыка());
	
КонецФункции

// Имя события журнала регистрации для записи ошибок подготовки области данных.
//
// Возвращаемое значение:
//  Строка - имя события ошибки.
//
Функция СобытиеЖурналаРегистрацииПодготовкаОбластиДанных() Экспорт
	
	Возврат НСтр("ru = 'Работа в модели сервиса.Подготовка области данных'", ОбщегоНазначения.КодОсновногоЯзыка());
	
КонецФункции

// Имя события журнала регистрации для записи ошибок получения файла из хранилища.
//
// Возвращаемое значение:
//  Строка - имя события ошибки.
//
Функция СобытиеЖурналаРегистрацииПолучениеФайлаИзХранилища() Экспорт
	
	Возврат НСтр("ru = 'Работа в модели сервиса.Получение файла из хранилища'", ОбщегоНазначения.КодОсновногоЯзыка());
	
КонецФункции

// Имя события журнала регистрации для записи ошибок добавления файла при обмене через файловую систему.
//
// Возвращаемое значение:
//  Строка - имя события ошибки.
//
Функция СобытиеЖурналаРегистрацииДобавлениеФайлаОбменЧерезФС() Экспорт
	
	Возврат НСтр("ru = 'Работа в модели сервиса.Добавление файла.Обмен через ФС'", ОбщегоНазначения.КодОсновногоЯзыка());
	
КонецФункции

// Имя события журнала регистрации для записи ошибок добавления файла при обмене не через файловую систему.
//
// Возвращаемое значение:
//  Строка - имя события ошибки.
//
Функция СобытиеЖурналаРегистрацииДобавлениеФайлаОбменНеЧерезФС() Экспорт
	
	Возврат НСтр("ru = 'Работа в модели сервиса.Добавление файла.Обмен не через ФС'", ОбщегоНазначения.КодОсновногоЯзыка());
	
КонецФункции

// Имя события журнала регистрации для записи ошибок удаления временного файла.
//
// Возвращаемое значение:
//  Строка - имя события ошибки.
//
Функция СобытиеЖурналаРегистрацииУдалениеВременногоФайла() Экспорт
	
	Возврат НСтр("ru = 'Работа в модели сервиса.Удаление временного файла'", ОбщегоНазначения.КодОсновногоЯзыка());
	
КонецФункции

// Прочее

// См. РаботаВМоделиСервисаПереопределяемый.ПриЗаполненииТаблицыПараметровИБ
Процедура ПриЗаполненииТаблицыПараметровИБ(Знач ТаблицаПараметров) Экспорт
	
	Если ЭтоРазделеннаяКонфигурация() Тогда
		ДобавитьКонстантуВТаблицуПараметровИБ(ТаблицаПараметров, "ИспользоватьРазделениеПоОбластямДанных");
		
		ДобавитьКонстантуВТаблицуПараметровИБ(ТаблицаПараметров, "РежимИспользованияИнформационнойБазы");
		
		ДобавитьКонстантуВТаблицуПараметровИБ(ТаблицаПараметров, "КопироватьОбластиДанныхИзЭталонной");
	КонецЕсли;
	
	ДобавитьКонстантуВТаблицуПараметровИБ(ТаблицаПараметров, "ВнутреннийАдресМенеджераСервиса");
	
	СтрокаПараметра = ТаблицаПараметров.Добавить();
	СтрокаПараметра.Имя = "ВнутреннийАдресМенеджераСервиса";
	СтрокаПараметра.Описание = НСтр("ru = 'Внутренний адрес Менеджера сервиса'");
	СтрокаПараметра.Тип = Новый ОписаниеТипов("Строка");
	
	// Для совместимости с предыдущими версиями необходим параметр "URLСервиса"
	СтрокаПараметра = ТаблицаПараметров.Добавить();
	СтрокаПараметра.Имя = "URLСервиса";
	СтрокаПараметра.Описание = НСтр("ru = 'Внутренний адрес Менеджера сервиса'");
	СтрокаПараметра.Тип = Новый ОписаниеТипов("Строка");
	
	СтрокаПараметра = ТаблицаПараметров.Добавить();
	СтрокаПараметра.Имя = "ИмяСлужебногоПользователяМенеджераСервиса";
	СтрокаПараметра.Описание = "ИмяСлужебногоПользователяМенеджераСервиса";
	СтрокаПараметра.Тип = Новый ОписаниеТипов("Строка");
	
	СтрокаПараметра = ТаблицаПараметров.Добавить();
	СтрокаПараметра.Имя = "ПарольСлужебногоПользователяМенеджераСервиса";
	СтрокаПараметра.Описание = "ПарольСлужебногоПользователяМенеджераСервиса";
	СтрокаПараметра.Тип = Новый ОписаниеТипов("Строка");
	СтрокаПараметра.ЗапретЧтения = Истина;
	
	СтрокаПараметра = ТаблицаПараметров.Добавить();
	СтрокаПараметра.Имя = "ИмяСлужебногоПользователяСервиса";
	СтрокаПараметра.Описание = "ИмяСлужебногоПользователяСервиса";
	СтрокаПараметра.Тип = Новый ОписаниеТипов("Строка");
	
	СтрокаПараметра = ТаблицаПараметров.Добавить();
	СтрокаПараметра.Имя = "ПарольСлужебногоПользователяСервиса";
	СтрокаПараметра.Описание = "ПарольСлужебногоПользователяСервиса";
	СтрокаПараметра.Тип = Новый ОписаниеТипов("Строка");
	СтрокаПараметра.ЗапретЧтения = Истина;
	// Конец Для совместимости с предыдущими версиями.
	
	СтрокаПараметра = ТаблицаПараметров.Добавить();
	СтрокаПараметра.Имя = "ВерсияКонфигурации";
	СтрокаПараметра.Описание = НСтр("ru = 'Версия конфигурации'");
	СтрокаПараметра.ЗапретЗаписи = Истина;
	СтрокаПараметра.Тип = Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная));
	
	ИнтеграцияПодсистемБТС.ПриЗаполненииТаблицыПараметровИБ(ТаблицаПараметров);
	
КонецПроцедуры

// Получает описание файла по его идентификатору в регистре Файлы.
// Если хранение на диске и ПутьВместоДанных = Истина, 
// в выходной структуре Данные = Неопределено, ПолноеИмя = Полное имя файла,
// иначе Данные - двоичные данные файла, ПолноеИмя - Неопределено.
// Значение ключа Имя всегда содержит имя в хранилище.
//
// Параметры:
//   ИдентификаторФайла - УникальныйИдентификатор - уникальный идентификатор файла,
//   ПараметрыПодключения - Структура:
//              * URL - Строка - URL сервиса, обязательно должно присутствовать и быть заполненным,
//              * UserName - Строка - имя пользователя сервиса,
//              * Password - Строка - пароль пользователя сервиса,
//   ПутьВместоДанных - Булево - что возвращать,
//   ПроверятьСуществование - Булево - проверять ли существование файла в случае ошибки его получения.
//		
// Возвращаемое значение:
//   Структура:
//     * Имя - Строка - имя файла в хранилище.
//     * Данные - ДвоичныеДанные - данные файла.
//     * ПолноеИмя - Строка - полное имя файла (файл будет удален автоматически по истечении срока хранения временных файлов).
//
Функция ПолучитьФайлИзХранилища(Знач ИдентификаторФайла, Знач ПараметрыПодключения, 
	Знач ПутьВместоДанных = Ложь, Знач ПроверятьСуществование = Ложь) Экспорт
	
	НачалоВыполнения = ТекущаяУниверсальнаяДата();
	
	ОписаниеПрокси = ОписаниеПроксиСервисаПередачиФайлов(ПараметрыПодключения);
	
	ОбменЧерезФС = МожноПередаватьЧерезФСССервера(ОписаниеПрокси.Прокси, ОписаниеПрокси.ЕстьПоддержка2йВерсии);
	
	Если ОбменЧерезФС Тогда
			
		Попытка
			Попытка
				ИмяФайла = ОписаниеПрокси.Прокси.WriteFileToFS(ИдентификаторФайла);
			Исключение
				ОписаниеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
				Если ПроверятьСуществование И Не ОписаниеПрокси.Прокси.FileExists(ИдентификаторФайла) Тогда
					Возврат Неопределено;
				КонецЕсли;
				ВызватьИсключение ОписаниеОшибки;
			КонецПопытки;
			
			СвойстваФайла = Новый Файл(ФайлыБТС.ОбщийКаталогВременныхФайлов() + ИмяФайла);
			Если СвойстваФайла.Существует() Тогда
				ОписаниеФайла = СоздатьОписаниеФайла();
				ОписаниеФайла.Имя = СвойстваФайла.Имя;
				
				РазмерПолученногоФайла = СвойстваФайла.Размер();
				
				Если ПутьВместоДанных Тогда
					ОписаниеФайла.Данные = Неопределено;
					ОписаниеФайла.ПолноеИмя = СвойстваФайла.ПолноеИмя;
				Иначе
					ОписаниеФайла.Данные = Новый ДвоичныеДанные(СвойстваФайла.ПолноеИмя);
					ОписаниеФайла.ПолноеИмя = Неопределено;
					Попытка
						УдалитьФайлы(СвойстваФайла.ПолноеИмя);
					Исключение
						ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииПолучениеФайлаИзХранилища(),
							УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
					КонецПопытки;
				КонецЕсли;
				
				ЗаписатьВЖурналСобытиеФайловогоХранилища(
					НСтр("ru = 'Извлечение'", ОбщегоНазначения.КодОсновногоЯзыка()),
					ИдентификаторФайла,
					РазмерПолученногоФайла,
					ТекущаяУниверсальнаяДата() - НачалоВыполнения,
					ОбменЧерезФС);
				
				Возврат ОписаниеФайла;
			Иначе
				ОбменЧерезФС = Ложь;
			КонецЕсли;
		Исключение
			ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииПолучениеФайлаИзХранилища(),
				УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			ОбменЧерезФС = Ложь;
		КонецПопытки;
			
	КонецЕсли; // ОбменЧерезФС
	
	КоличествоЧастей = Неопределено;
	РазмерБлокаПередачиФайла = ПолучитьРазмерБлокаПередачиФайла();
	Попытка
		Если ОписаниеПрокси.ЕстьПоддержка2йВерсии Тогда
			ИдентификаторПередачи = ОписаниеПрокси.Прокси.PrepareGetFile(ИдентификаторФайла, РазмерБлокаПередачиФайла * 1024, КоличествоЧастей);
		Иначе
			ИдентификаторПередачи = Неопределено;
			ОписаниеПрокси.Прокси.PrepareGetFile(ИдентификаторФайла, РазмерБлокаПередачиФайла * 1024, ИдентификаторПередачи, КоличествоЧастей);
		КонецЕсли;
	Исключение
		ОписаниеОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		Если ПроверятьСуществование И Не ОписаниеПрокси.Прокси.FileExists(ИдентификаторФайла) Тогда
			Возврат Неопределено;
		КонецЕсли;
		ВызватьИсключение ОписаниеОшибки;
	КонецПопытки;
	
	ИменаФайлов = Новый Массив;
	
	КаталогСборки = СоздатьКаталогСборки();
	
	Если ОписаниеПрокси.ЕстьПоддержка2йВерсии Тогда
		Для НомерЧасти = 1 По КоличествоЧастей Цикл
			ДанныеЧасти = ОписаниеПрокси.Прокси.GetFilePart(ИдентификаторПередачи, НомерЧасти, КоличествоЧастей);
			ИмяФайлаЧасти = КаталогСборки + "part" + Формат(НомерЧасти, "ЧЦ=4; ЧВН=; ЧГ=");
			Если ТипЗнч(ДанныеЧасти) = Тип("ДвоичныеДанные") Тогда
				ДанныеЧасти.Записать(ИмяФайлаЧасти);
			КонецЕсли;
			ИменаФайлов.Добавить(ИмяФайлаЧасти);
		КонецЦикла;
	Иначе // 1-я версия.
		Для НомерЧасти = 1 По КоличествоЧастей Цикл
			ДанныеЧасти = Неопределено;
			ОписаниеПрокси.Прокси.GetFilePart(ИдентификаторПередачи, НомерЧасти, ДанныеЧасти);
			ИмяФайлаЧасти = КаталогСборки + "part" + Формат(НомерЧасти, "ЧЦ=4; ЧВН=; ЧГ=");
			Если ТипЗнч(ДанныеЧасти) = Тип("ДвоичныеДанные") Тогда
				ДанныеЧасти.Записать(ИмяФайлаЧасти);
			КонецЕсли;
			ИменаФайлов.Добавить(ИмяФайлаЧасти);
		КонецЦикла;
	КонецЕсли;
	ДанныеЧасти = Неопределено;
	
	ОписаниеПрокси.Прокси.ReleaseFile(ИдентификаторПередачи);
	
	ИмяАрхива = ПолучитьИмяВременногоФайла("zip");
	
	Попытка
	
		ОбъединитьФайлы(ИменаФайлов, ИмяАрхива);
		ФайлОбъединен = Истина;
		
	Исключение
		
		ФайлОбъединен = Ложь;
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Выполнение операции объединения файлов'", ОбщегоНазначения.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			
	КонецПопытки;
	
	Если ФайлОбъединен Тогда
		
		Попытка
		
			ЧтениеZipФайла = Новый ЧтениеZipФайла(ИмяАрхива);
			ПрочитанZipФайл = Истина;
			
		Исключение
			
			ПрочитанZipФайл = Ложь;
			ЗаписьЖурналаРегистрации(НСтр("ru = 'Выполнение операции чтения zip файла'", ОбщегоНазначения.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
				
		КонецПопытки;
		
		Если ПрочитанZipФайл Тогда
			
			ВПолученномАрхивеБолееОдногоФайла = ЧтениеZipФайла.Элементы.Количество() > 1;
			
			Если НЕ ВПолученномАрхивеБолееОдногоФайла Тогда
				
				ИмяФайла = КаталогСборки + ЧтениеZipФайла.Элементы.Получить(0).Имя;
				ЧтениеZipФайла.Извлечь(ЧтениеZipФайла.Элементы.Получить(0), КаталогСборки);
				ЧтениеZipФайла.Закрыть();
				
				ФайлРезультата = Новый Файл(ПолучитьИмяВременногоФайла());
				ПереместитьФайл(ИмяФайла, ФайлРезультата.ПолноеИмя);
				РазмерПолученногоФайла = ФайлРезультата.Размер();
				
				ОписаниеФайла = СоздатьОписаниеФайла();
				ОписаниеФайла.Имя = ФайлРезультата.Имя;
				
				Если ПутьВместоДанных Тогда
					
					ОписаниеФайла.Данные = Неопределено;
					ОписаниеФайла.ПолноеИмя = ФайлРезультата.ПолноеИмя;
					
				Иначе
					
					ОписаниеФайла.Данные = Новый ДвоичныеДанные(ФайлРезультата.ПолноеИмя);
					ОписаниеФайла.ПолноеИмя = Неопределено;
					
					Попытка
						
						УдалитьФайлы(ФайлРезультата.ПолноеИмя);
						
					Исключение
						
						ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииПолучениеФайлаИзХранилища(),
							УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
							
					КонецПопытки;
						
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	ФайлВременный = Новый Файл(ИмяАрхива);
	
	Если ФайлВременный.Существует() Тогда
		
		Попытка
			
			ФайлВременный.УстановитьТолькоЧтение(Ложь);
			УдалитьФайлы(ИмяАрхива);
			
		Исключение
			
			ЗаписьЖурналаРегистрации(НСтр("ru = 'Выполнение операции удаления временного файла'", ОбщегоНазначения.КодОсновногоЯзыка()),
				УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
				
		КонецПопытки;
		
	КонецЕсли;
	
	Попытка
		
		УдалитьФайлы(КаталогСборки);
		
	Исключение
		
		ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииПолучениеФайлаИзХранилища(),
			УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			
	КонецПопытки;
		
	Если НЕ ПрочитанZipФайл Тогда
		
		ВызватьИсключение(НСтр("ru = 'При чтении zip файла произошла ошибка.'"));
		
	КонецЕсли;
	
	Если ВПолученномАрхивеБолееОдногоФайла Тогда
		
		ВызватьИсключение(НСтр("ru = 'В полученном архиве содержится более одного файла.'"));
		
	КонецЕсли;
	
	ЗаписатьВЖурналСобытиеФайловогоХранилища(
		НСтр("ru = 'Извлечение'", ОбщегоНазначения.КодОсновногоЯзыка()),
		ИдентификаторФайла,
		РазмерПолученногоФайла,
		ТекущаяУниверсальнаяДата() - НачалоВыполнения,
		ОбменЧерезФС);
	
	Возврат ОписаниеФайла;
	
КонецФункции

// Записывает тестовый файл на диск, возвращая его имя и размер.
// Файл должна удалять вызывающая сторона.
//
// Возвращаемое значение:
//   Строка - имя пробного файла без пути.
//
Функция ЗаписатьПробныйФайл() Экспорт
	
	НовыйИД = Новый УникальныйИдентификатор;
	СвойстваФайла = Новый Файл(ФайлыБТС.ОбщийКаталогВременныхФайлов() + НовыйИД + ".tmp");
	
	Текст = Новый ЗаписьТекста(СвойстваФайла.ПолноеИмя, КодировкаТекста.ANSI);
	Текст.Записать(НовыйИД);
	Текст.Закрыть();
	
	Возврат СвойстваФайла.Имя;
	
КонецФункции

// Дополнительные действия, выполняемые при изменении разделения сеанса.
//
Процедура ПриИзмененииОбластиДанных() Экспорт
	
	ОчиститьВсеПараметрыСеансаКромеРазделителей();
	
	Если ДоступноИспользованиеРазделенныхДанных()
		И ТекущийРежимЗапуска() <> Неопределено Тогда
		
		МенеджерЗаписи = РегистрыСведений.ОбластиДанных.СоздатьМенеджерЗаписи();
		МенеджерЗаписи.Прочитать();
		
		Если МенеджерЗаписи.Выбран() Тогда
			
			Если НЕ (МенеджерЗаписи.ОшибкаОбработки
				ИЛИ МенеджерЗаписи.Статус = Перечисления.СтатусыОбластейДанных.КУдалению
				ИЛИ МенеджерЗаписи.Статус = Перечисления.СтатусыОбластейДанных.Удалена) Тогда
		
				ПользователиСлужебный.АвторизоватьТекущегоПользователя();
			
			КонецЕсли;
			
		Иначе
			
			ПользователиСлужебный.АвторизоватьТекущегоПользователя();
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Регистрирует обработчики поставляемых данных за день и за все время.
//
// Параметры:
//   Обработчики - ТаблицаЗначений - таблица обработчиков.
//
Процедура ЗарегистрироватьОбработчикиПоставляемыхДанных(Знач Обработчики) Экспорт
	
	Обработчик = Обработчики.Добавить();
	Обработчик.ВидДанных = "ЭталонОбластиДанных";
	Обработчик.КодОбработчика = "ЭталонОбластиДанных";
	Обработчик.Обработчик = РаботаВМоделиСервиса;
	
КонецПроцедуры

// Вызывается при получении уведомления о новых данных.
// В теле следует проверить, необходимы ли эти данные приложению, 
// и если да - установить флажок Загружать.
// 
// Параметры:
//   Дескриптор - ОбъектXDTO, Структура
//   Загружать - Булево - Истина, если загружать, Ложь - иначе.
//   ДескрипторJSON - Булево - флаг обозначающий что дескриптор пришел в формате JSON
//
Процедура ДоступныНовыеДанные(Знач Дескриптор, Загружать, Знач ДескрипторJSON = Ложь) Экспорт
	
	Если Дескриптор.DataType = "ЭталонОбластиДанных" Тогда
		УсловиеИмениКонфигурации = Ложь;
		УсловиеВерсииКонфигурации = Ложь;
		Для каждого Характеристика Из Дескриптор.Properties.Property Цикл
			Если Не УсловиеИмениКонфигурации Тогда
				УсловиеИмениКонфигурации = Характеристика.Code = "ИмяКонфигурации" И Характеристика.Value = Метаданные.Имя;
			КонецЕсли;
			Если Не УсловиеВерсииКонфигурации Тогда
				УсловиеВерсииКонфигурации = Характеристика.Code = "ВерсияКонфигурации"
					И ОбщегоНазначенияКлиентСервер.СравнитьВерсии(Характеристика.Value, Метаданные.Версия) >= 0;
			КонецЕсли;
		КонецЦикла;
		Загружать = УсловиеИмениКонфигурации И УсловиеВерсииКонфигурации;
	КонецЕсли;
	
КонецПроцедуры

// Вызывается при получении уведомления о новых данных.
// В теле следует проверить, необходимы ли эти данные приложению, 
// и если да - установить флажок Загружать.
// 
// Параметры:
//   Дескриптор - Структура
//   Загружать - Булево - Истина, если загружать, Ложь - иначе.
//
Процедура ДоступныНовыеДанныеJSON(Знач Дескриптор, Загружать) Экспорт
	
	ДоступныНовыеДанные(Дескриптор, Загружать, Истина);
	
КонецПроцедуры

// Вызывается после вызова ДоступныНовыеДанные, позволяет разобрать данные.
//
// Параметры:
//   Дескриптор - ОбъектXDTO, Структура
//   ПутьКФайлу - Строка - полное имя извлеченного файла. Файл будет автоматически удален 
//                  после завершения процедуры. Если в менеджере сервиса не был
//                  указан файл - значение аргумента равно Неопределено.
//   ДескрипторJSON - Булево - флаг обозначающий что дескриптор пришел в формате JSON
//
Процедура ОбработатьНовыеДанные(Знач Дескриптор, Знач ПутьКФайлу, Знач ДескрипторJSON = Ложь) Экспорт
	
	Если Дескриптор.DataType = "ЭталонОбластиДанных" Тогда
		ОбработатьПоставляемыйЭталонКонфигурации(Дескриптор, ПутьКФайлу);
	КонецЕсли;
	
КонецПроцедуры

// Вызывается после вызова ДоступныНовыеДанные, позволяет разобрать данные.
//
// Параметры:
//   Дескриптор - Структура
//   ПутьКФайлу - Строка - полное имя извлеченного файла. Файл будет автоматически удален 
//                  после завершения процедуры. Если в менеджере сервиса не был
//                  указан файл - значение аргумента равно Неопределено.
//
Процедура ОбработатьНовыеДанныеJSON(Знач Дескриптор, Знач ПутьКФайлу) Экспорт
	
	ОбработатьНовыеДанные(Дескриптор, ПутьКФайлу, Истина);
	
КонецПроцедуры

// Вызывается при отмене обработки данных в случае сбоя.
//
// Параметры:
//   Дескриптор - ОбъектXDTO - дескриптор.
//
Процедура ОбработкаДанныхОтменена(Знач Дескриптор) Экспорт 
	Возврат;	
КонецПроцедуры

// Для общего модуля РаботаВМоделиСервисаПовтИсп.

// Определяет, запущен сеанс с разделителями или без.
//
// Возвращаемое значение:
//   Булево - Истина, если сеанс запущен без разделителей.
//
Функция СеансЗапущенБезРазделителей() Экспорт
	
	Возврат ПользователиИнформационнойБазы.ТекущийПользователь().РазделениеДанных.Количество() = 0;
	
КонецФункции

// Возвращает признак наличия в конфигурации общих реквизитов-разделителей.
//
// Возвращаемое значение:
//   Булево - Истина, если это разделенная конфигурация.
//
Функция ЭтоРазделеннаяКонфигурация() Экспорт
	
	Возврат РаботаВМоделиСервисаПовтИсп.ЭтоРазделеннаяКонфигурация();
	
КонецФункции

// Возвращает признак того, что объект метаданных используется в общих реквизитах-разделителях.
//
// Параметры:
//   ОбъектМетаданных - Строка - имя объекта метаданных.
//   Разделитель - Строка - имя общего реквизита-разделителя, на разделение которыми проверяется объект метаданных.
//
// Возвращаемое значение:
//   Булево - Истина, если это разделенный объект.
//
Функция ЭтоРазделенныйОбъектМетаданных(Знач ОбъектМетаданных, Знач Разделитель = Неопределено) Экспорт
	
	Если ТипЗнч(ОбъектМетаданных) = Тип("Строка") Тогда
		ПолноеИмяОбъектаМетаданных = ОбъектМетаданных;
	Иначе
		ПолноеИмяОбъектаМетаданных = ОбъектМетаданных.ПолноеИмя();
	КонецЕсли;
	
	Возврат РаботаВМоделиСервисаПовтИсп.ЭтоРазделенныйОбъектМетаданных(ПолноеИмяОбъектаМетаданных, Разделитель);
	
КонецФункции

// Возвращает массив сериализуемых структурных типов, поддерживаемых в настоящее время.
//
// Возвращаемое значение:
//   ФиксированныйМассив из Тип - массив из типа Тип.
//
Функция СериализуемыеСтруктурныеТипы() Экспорт
	
	Возврат РаботаВМоделиСервисаПовтИсп.СериализуемыеСтруктурныеТипы();
	
КонецФункции

// Возвращает конечную точку для отправки сообщений в менеджер сервиса.
//
// Возвращаемое значение:
//  ПланОбменаСсылка.ОбменСообщениями - узел соответствующий менеджеру сервиса.
//
Функция КонечнаяТочкаМенеджераСервиса() Экспорт
	
	Возврат РаботаВМоделиСервисаБТС.КонечнаяТочкаМенеджераСервиса();
	
КонецФункции

// Возвращает соответствие видов контактной информации пользователя видам.
// КИ используемой в XDTO модели сервиса.
//
// Возвращаемое значение:
//  Соответствие - соответствие видов КИ.
//
Функция СоответствиеВидовКИПользователяXDTO() Экспорт
	
	Возврат РаботаВМоделиСервисаПовтИсп.СоответствиеВидовКИПользователяXDTO();
	
КонецФункции

// Возвращает соответствие видов контактной информации XDTO видам.
// КИ пользователя.
//
// Возвращаемое значение:
//  Соответствие - соответствие видов КИ.
//
Функция СоответствиеВидовКИXDTOВидамКИПользователя() Экспорт
	
	Возврат РаботаВМоделиСервисаПовтИсп.СоответствиеВидовКИXDTOВидамКИПользователя();
	
КонецФункции

// Возвращает соответствие прав XDTO используемым в модели сервиса возможным
// действиям с пользователем сервиса.
// 
// Возвращаемое значение:
//  Соответствие из КлючИЗначение - соответствие прав действиям.
//
Функция СоответствиеПравXDTOДействиямСПользователемСервиса() Экспорт
	
	Возврат РаботаВМоделиСервисаПовтИсп.СоответствиеПравXDTOДействиямСПользователемСервиса();
	
КонецФункции

// Возвращает описание модели данных, относящихся к области данных.
//
// Возвращаемое значение:
//  ФиксированноеСоответствие из КлючИЗначение:
//    * Ключ - ОбъектМетаданных - объект метаданных,
//    * Значение - Строка - имя общего реквизита-разделителя.
//
Функция ПолучитьМодельДанныхОбласти() Экспорт
	
	Возврат РаботаВМоделиСервисаПовтИсп.ПолучитьМодельДанныхОбласти();
	
КонецФункции

// Возвращает массив существующих в конфигурации разделителей.
//
// Возвращаемое значение:
//   ФиксированныйМассив - массив имен общих реквизитов, которые
//     являются разделителями.
//
Функция РазделителиКонфигурации() Экспорт
	
	Возврат РаботаВМоделиСервисаПовтИсп.РазделителиКонфигурации();
	
КонецФункции

// Возвращает состав общего реквизита с заданным именем.
//
// Параметры:
//   Имя - Строка - имя общего реквизита.
//
// Возвращаемое значение:
//   СоставОбщегоРеквизита - список объектов метаданных, в которые входит общий реквизит.
//
Функция СоставОбщегоРеквизита(Знач Имя) Экспорт
	
	Возврат РаботаВМоделиСервисаПовтИсп.СоставОбщегоРеквизита(Имя);
	
КонецФункции

#Область УстаревшиеПроцедурыИФункции

// Устарела. Следует использовать метод платформы УстановитьМонопольныйРежим(Истина).
//
// Параметры:
//  ПроверитьОтсутствиеДругихСеансов - Булево - проверять отсутствие других сеансов или нет.
//  РазделяемаяБлокировка - Булево - это разделяемая блокировка.
//
Процедура ЗаблокироватьТекущуюОбластьДанных(Знач ПроверитьОтсутствиеДругихСеансов = Ложь, Знач РазделяемаяБлокировка = Ложь) Экспорт
	
	Если НЕ ДоступноИспользованиеРазделенныхДанных() Тогда
		ВызватьИсключение(НСтр("ru = 'Блокировка области может быть установлена только при включенном использовании разделителей'"));
	КонецЕсли;
	
	Ключ = СоздатьКлючЗаписиРегистраСведенийВспомогательныхДанных(
		РегистрыСведений.ОбластиДанных,
		Новый Структура(РазделительВспомогательныхДанных(), ЗначениеРазделителяСеанса()));
	
	КоличествоПопыток = 5;
	ТекущаяПопытка = 0;
	Пока Истина Цикл
		Попытка
			ЗаблокироватьДанныеДляРедактирования(Ключ);
			Прервать;
		Исключение
			ТекущаяПопытка = ТекущаяПопытка + 1;
			
			Если ТекущаяПопытка = КоличествоПопыток Тогда
				ШаблонКомментария = НСтр("ru = 'Не удалось установить блокировку области данных по причине:
					|%1'");
				ТекстКомментария = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонКомментария, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
				ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииБлокировкаОбластиДанных(),
					УровеньЖурналаРегистрации.Ошибка,
					,
					,
					ТекстКомментария);
					
				ШаблонТекста = НСтр("ru = 'Не удалось установить блокировку области данных по причине:
					|%1'");
				Текст = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонТекста, КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
					
				ВызватьИсключение(Текст);
			КонецЕсли;
		КонецПопытки;
	КонецЦикла;
	
	Если ПроверитьОтсутствиеДругихСеансов Тогда
		
		КонфликтующиеСеансы = Новый Массив; // Массив Из СеансИнформационнойБазы
		
		Для каждого Сеанс Из ПолучитьСеансыИнформационнойБазы() Цикл
			Если Сеанс.НомерСеанса = НомерСеансаИнформационнойБазы() Тогда
				Продолжить;
			КонецЕсли;
			
			КлиентскиеПриложения = Новый Массив;
			КлиентскиеПриложения.Добавить(ВРег("1CV8"));
			КлиентскиеПриложения.Добавить(ВРег("1CV8C"));
			КлиентскиеПриложения.Добавить(ВРег("WebClient"));
			КлиентскиеПриложения.Добавить(ВРег("COMConnection"));
			КлиентскиеПриложения.Добавить(ВРег("WSConnection"));
			КлиентскиеПриложения.Добавить(ВРег("BackgroundJob"));
			Если КлиентскиеПриложения.Найти(ВРег(Сеанс.ИмяПриложения)) = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			КонфликтующиеСеансы.Добавить(Сеанс);
			
		КонецЦикла;
		
		Если КонфликтующиеСеансы.Количество() > 0 Тогда
			
			РазблокироватьДанныеДляРедактирования(Ключ);
			
			ТекстСеансы = "";
			Для Каждого КонфликтующийСеанс Из КонфликтующиеСеансы Цикл
				
				Если Не ПустаяСтрока(ТекстСеансы) Тогда
					ТекстСеансы = ТекстСеансы + ", ";
				КонецЕсли;
				
				ТекстСеансы = ТекстСеансы + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = '%1 (сеанс - %2)'", ОбщегоНазначения.КодОсновногоЯзыка()),
					КонфликтующийСеанс.Пользователь.Имя,
					Формат(КонфликтующийСеанс.НомерСеанса, "ЧГ=0"));
				
			КонецЦикла;
			
			ТекстИсключения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Операция не может быть выполнена, т.к. в приложении работают другие пользователи: %1'",
					ОбщегоНазначения.КодОсновногоЯзыка()),
				ТекстСеансы);
				
			ВызватьИсключение ТекстИсключения;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Если НЕ РазделяемаяБлокировка Тогда
		УстановитьМонопольныйРежим(Истина);
		Возврат;
	КонецЕсли;
	
	МодельДанных = РаботаВМоделиСервисаПовтИсп.ПолучитьМодельДанныхОбласти();
	
	Блокировка = Новый БлокировкаДанных;
	
	Для Каждого ЭлементМодели Из МодельДанных Цикл
		
		ПолноеИмяОбъектаМетаданных = ЭлементМодели.Ключ;
		ОписаниеОбъектаМетаданных = ЭлементМодели.Значение; // ОбъектМетаданных
		
		ПространствоБлокировки = ПолноеИмяОбъектаМетаданных;
		
		Если ЭтоПолноеИмяРегистра(ПолноеИмяОбъектаМетаданных) Тогда
			
			БлокироватьНаборы = Истина;
			Если ЭтоПолноеИмяРегистраСведений(ПолноеИмяОбъектаМетаданных) Тогда
				ОбъектМетаданныхОбласти = Метаданные.РегистрыСведений.Найти(ОписаниеОбъектаМетаданных.Имя);
				Если ОбъектМетаданныхОбласти.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.Независимый Тогда
					БлокироватьНаборы = Ложь;
				КонецЕсли;
			КонецЕсли;
			
			Если БлокироватьНаборы Тогда
				ПространствоБлокировки = ПространствоБлокировки + ".НаборЗаписей";
			КонецЕсли;
			
		ИначеЕсли ЭтоПолноеИмяПоследовательности(ПолноеИмяОбъектаМетаданных) Тогда
			
			ПространствоБлокировки = ПространствоБлокировки + ".Записи";
			
		ИначеЕсли ЭтоПолноеИмяЖурналаДокументов(ПолноеИмяОбъектаМетаданных)
				ИЛИ ЭтоПолноеИмяПеречисления(ПолноеИмяОбъектаМетаданных)
				ИЛИ ЭтоПолноеИмяПоследовательности(ПолноеИмяОбъектаМетаданных)
				ИЛИ ЭтоПолноеИмяРегламентногоЗадания(ПолноеИмяОбъектаМетаданных) Тогда
			
			Продолжить;
			
		КонецЕсли;
		
		ЭлементБлокировки = Блокировка.Добавить(ПространствоБлокировки);
		
		Если РазделяемаяБлокировка Тогда
			
			ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Блокировка.Заблокировать();
	
КонецПроцедуры

// Устарела. Следует использовать метод платформы УстановитьМонопольныйРежим(Ложь).
Процедура РазблокироватьТекущуюОбластьДанных() Экспорт
	
	Ключ = СоздатьКлючЗаписиРегистраСведенийВспомогательныхДанных(
		РегистрыСведений.ОбластиДанных,
		Новый Структура(РазделительВспомогательныхДанных(), ЗначениеРазделителяСеанса()));
		
	РазблокироватьДанныеДляРедактирования(Ключ);
	
	УстановитьМонопольныйРежим(Ложь);
	
КонецПроцедуры

#КонецОбласти

// Возвращает статус области данных.
//
// Параметры:
//  ОбластьДанных -  Число - значение разделителя области данных, 
//   статус которой требуется получить.
//
// Возвращаемое значение:
//  ПеречислениеСсылка.СтатусыОбластейДанных - статус области данных.
//
Функция СтатусОбластиДанных(ОбластьДанных) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст =
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	ОбластиДанных.Статус КАК Статус
		|ИЗ
		|	РегистрСведений.ОбластиДанных КАК ОбластиДанных
		|ГДЕ
		|	ОбластиДанных.ОбластьДанныхВспомогательныеДанные = &ОбластьДанных";
	Запрос.УстановитьПараметр("ОбластьДанных", ОбластьДанных);
	Результат = Запрос.Выполнить().Выгрузить();
	Если Результат.Количество() = 0 Тогда
		Возврат Неопределено;
	Иначе
		Возврат Результат[0].Статус;
	КонецЕсли;
	
КонецФункции

// Возвращает таблицу описания параметров ИБ.
//
// Возвращаемое значение:
//     ТаблицаЗначений - параметры ИБ. Содержит колонки:
//         * Имя - Строка - имя параметра.
//         * Описание - Строка - описание параметра для отображения в пользовательском интерфейсе.
//         * ЗапретЧтения - Булево - признак невозможности считывания параметра ИБ. Может быть установлен, например, для
//                                   паролей.
//         * ЗапретЗаписи - Булево - признак невозможности изменения параметра ИБ.
//         * Тип - ОписаниеТипов - тип значения параметра. Допускается использовать только примитивные типы и
//                                 перечисления, присутствующие в управляющем приложении.
//
Функция ПараметрыИБ() Экспорт
	
	ТаблицаПараметров = ШаблонПараметровИБ();
	
	ПриЗаполненииТаблицыПараметровИБ(ТаблицаПараметров);
	
	РаботаВМоделиСервисаПереопределяемый.ПриЗаполненииТаблицыПараметровИБ(ТаблицаПараметров);
	
	Возврат ТаблицаПараметров;
	
КонецФункции

// Возвращает флаг доступности действий изменения пользователей.
//
// Возвращаемое значение:
//   Булево - Истина, если изменение пользователей доступно, иначе Ложь.
//
Функция ДоступноИзменениеПользователей() Экспорт
	
	Возврат Константы.РежимИспользованияИнформационнойБазы.Получить() 
		<> Перечисления.РежимыИспользованияИнформационнойБазы.Демонстрационный;
	
КонецФункции

// Возвращает коллекцию используемых областей данных.
//
// Возвращаемое значение:
//   РезультатЗапроса - результат запроса, содержащего список областей данных.
//
Функция ИспользуемыеОбластиДанных() Экспорт
	Запрос = Новый Запрос();
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ОбластиДанных.ОбластьДанныхВспомогательныеДанные КАК ОбластьДанных
	|ИЗ
	|	РегистрСведений.ОбластиДанных КАК ОбластиДанных
	|ГДЕ
	|	ОбластиДанных.Статус = ЗНАЧЕНИЕ(Перечисление.СтатусыОбластейДанных.Используется)
	|УПОРЯДОЧИТЬ ПО
	|	ОбластьДанных";
	
	Результат = Запрос.Выполнить();
	
	Возврат Результат;
КонецФункции

// Создает ключ записи для регистра сведений, включенного в состав разделителя ОбластьДанныхВспомогательныеДанные.
//
// Параметры:
//  Менеджер - РегистрСведенийМенеджер - менеджер регистра сведений, для которого требуется получить ключ записи,
//  ЗначенияКлюча - Структура - содержащая значения для заполнения свойств ключа записи.
//                              Имена элементов структуры должны соответствовать именам ключевых полей.
//
// Возвращаемое значение:
//  РегистрСведенийКлючЗаписиИмяРегистраСведений - ключ записи.
//
Функция СоздатьКлючЗаписиРегистраСведенийВспомогательныхДанных(Знач Менеджер, Знач ЗначенияКлюча) Экспорт
	
	Ключ = Менеджер.СоздатьКлючЗаписи(ЗначенияКлюча);
	
	ОбластьДанных = Неопределено;
	Разделитель = РазделительВспомогательныхДанных();
	
	Если ЗначенияКлюча.Свойство(Разделитель, ОбластьДанных) Тогда
		
		Если Ключ[Разделитель] <> ОбластьДанных Тогда
			
			Объект = СериализаторXDTO.ЗаписатьXDTO(Ключ);
			Объект[Разделитель] = ОбластьДанных;
			Ключ = СериализаторXDTO.ПрочитатьXDTO(Объект);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Ключ;
	
КонецФункции

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

// Возвращает список полных имен всех объектов метаданных, использующихся в общем реквизите-разделителе,
//  имя которого передано в качестве значения параметра Разделитель, и значения свойств объекта метаданных,
//  которые могут потребоваться для дальнейшей его обработки в универсальных алгоритмах.
// Для последовательностей и журналов документов определяет разделенность по входящим документам: любому из.
//
// Параметры:
//  Разделитель - Строка - имя общего реквизита.
//
// Возвращаемое значение:
//   ФиксированноеСоответствие из КлючИЗначение:
//   * Ключ - Строка - полное имя объекта метаданных,
//   * Значение - ФиксированнаяСтруктура:
//    * Имя - Строка - имя объекта метаданных,
//    * Разделитель - Строка - имя разделителя, которым разделен объект метаданных,
//    * УсловноеРазделение - Строка - полное имя объекта метаданных, выступающего в качестве условия использования
//      разделения объекта метаданных данным разделителем.
//
Функция РазделенныеОбъектыМетаданных(Знач Разделитель) Экспорт
	
	Возврат РаботаВМоделиСервисаПовтИсп.РазделенныеОбъектыМетаданных(Разделитель);
	
КонецФункции

// Параметры:
//  ЗаданиеМетаданные - ОбъектМетаданных - метаданные предопределенного регламентного задания.
//  Использование     - Булево - Истина, если задание нужно включить, иначе Ложь.
//
Процедура УстановитьИспользованиеПредопределенногоРегламентногоЗадания(ЗаданиеМетаданные, Использование) Экспорт
	
	Шаблон = ОчередьЗаданий.ШаблонПоИмени(ЗаданиеМетаданные.Имя);
	
	ОтборЗадания = Новый Структура;
	ОтборЗадания.Вставить("Шаблон", Шаблон);
	Задания = ОчередьЗаданий.ПолучитьЗадания(ОтборЗадания);
	
	Если Задания.Количество() = 0 Тогда
		МонопольныйРежимУстановлен = МонопольныйРежим();
		Если Не МонопольныйРежимУстановлен Тогда
			Попытка
				УстановитьМонопольныйРежим(Истина);
				МонопольныйРежимУстановлен = Истина;
			Исключение
				МонопольныйРежимУстановлен = Ложь;
			КонецПопытки;
		КонецЕсли;
		Если МонопольныйРежим() Тогда
			Попытка
				ОчередьЗаданийСлужебныйРазделениеДанных.СоздатьЗаданияОчередиПоШаблонамВТекущейОбласти();
				ОбновлениеВыполнено = Истина;
			Исключение
				ОбновлениеВыполнено = Ложь;
			КонецПопытки;
			Если ОбновлениеВыполнено Тогда
				Задания = ОчередьЗаданий.ПолучитьЗадания(ОтборЗадания);
			КонецЕсли;
		КонецЕсли;
		Если МонопольныйРежимУстановлен Тогда
			УстановитьМонопольныйРежим(Ложь);
		КонецЕсли;
	КонецЕсли;
	Если Задания.Количество() = 0 Тогда
		ШаблонСообщения = НСтр("ru = 'Не найдено задание в очереди для предопределенного задания с именем %1'");
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, ЗаданиеМетаданные.Имя);
		ВызватьИсключение(ТекстСообщения);
	КонецЕсли;
	
	ПараметрыЗадания = Новый Структура("Использование", Использование);
	ОчередьЗаданий.ИзменитьЗадание(Задания.Получить(0).Идентификатор, ПараметрыЗадания);
	
КонецПроцедуры

// Проверяет возможность использования конфигурации в модели сервиса.
//  При невозможности использования - генерируется исключение с указанием причины,
//  из-за которой использование конфигурации в модели сервиса невозможно.
//
Процедура ПроверитьВозможностьИспользованияКонфигурацииВМоделиСервиса() Экспорт
	
	ОписанияПодсистем = ОбщегоНазначения.ОписанияПодсистем();
	
	ОписаниеБТС = Неопределено;
	
	Для каждого ОписаниеПодсистемы Из ОписанияПодсистем Цикл
		
		Если ОписаниеПодсистемы.Имя = "БиблиотекаТехнологииСервиса" Тогда
			
			ОписаниеБТС = ОписаниеПодсистемы;
			Прервать;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Если ОписаниеБТС = Неопределено Тогда
		
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'В конфигурацию не внедрена библиотека ""1С:Библиотека технологии сервиса"".
                  |Без внедрения этой библиотеки конфигурация не может использоваться в модели сервиса.
                  |
                  |Для использования этой конфигурации в модели сервиса требуется внедрить библиотеку
                  |""1С:Библиотека технологии сервиса"" версии не младше %1.'", Метаданные.ОсновнойЯзык.КодЯзыка),
			ТребуемаяВерсияБТС());
		
	Иначе
		
		ВерсияБТС = ОписаниеБТС.Версия;
		
		Если ОбщегоНазначенияКлиентСервер.СравнитьВерсии(ВерсияБТС, ТребуемаяВерсияБТС()) < 0 Тогда
			
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Для использования конфигурации в модели сервиса с текущей версией БСП требуется
                      |обновить используемую версию библиотеки ""1С:Библиотека технологии сервиса"".
                      |
                      |Используемая версия: %1, требуется версия не младше %2.'", Метаданные.ОсновнойЯзык.КодЯзыка),
				ВерсияБТС, ТребуемаяВерсияБТС());
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Вызывает исключение при отсутствии требуемой подсистемы из библиотеки технологии сервиса.
//
// Параметры:
//  ИмяПодсистемы - Строка - имя подсистемы. 
//
Процедура ВызватьИсключениеОтсутствуетПодсистемаБТС(Знач ИмяПодсистемы) Экспорт
	
	ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Невозможно выполнить операцию по причине - в конфигурации не внедрена подсистема ""%1"".
              |Данная подсистема поставляется в состав библиотеки технологии сервиса, которая должна отдельно внедряться в состав конфигурации.
              |Проверьте наличие и корректность внедрения подсистемы ""%1"".'"),
		ИмяПодсистемы);
	
КонецПроцедуры

// Пытается выполнить запрос в несколько попыток.
// Используется для чтения вне транзакции часто изменяемых данных.
// При вызове в транзакции выдает ошибку.
//
// Параметры:
//  Запрос - Запрос - запрос который требуется выполнить.
//
// Возвращаемое значение:
//  РезультатЗапроса - результат выполнения запроса.
//
Функция ВыполнитьЗапросВнеТранзакции(Знач Запрос) Экспорт
	
	Если ТранзакцияАктивна() Тогда
		ВызватьИсключение(НСтр("ru = 'Транзакция активна. Выполнение запроса вне транзакции невозможно.'"));
	КонецЕсли;
	
	КоличествоПопыток = 0;
	
	Результат = Неопределено;
	Пока Истина Цикл
		Попытка
			Результат = Запрос.Выполнить(); // Чтение вне транзакции, возможно появление ошибки.
			                                // Could not continue scan with NOLOCK due to data movement
			                                // в этом случае нужно повторить попытку чтения.
			Прервать;
		Исключение
			КоличествоПопыток = КоличествоПопыток + 1;
			Если КоличествоПопыток = 5 Тогда
				ВызватьИсключение;
			КонецЕсли;
		КонецПопытки;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Возвращает XML представление типа XDTO.
//
// Параметры:
//  ТипXDTO - ТипОбъектаXDTO, ТипЗначенияXDTO - тип XDTO для которого требуется получить.
//   XML представление.
//
// Возвращаемое значение:
//  Строка - XML представление типа XDTO.
//
Функция ПредставлениеТипаXDTO(ТипXDTO) Экспорт
	
	Возврат СериализаторXDTO.XMLСтрока(Новый РасширенноеИмяXML(ТипXDTO.URIПространстваИмен, ТипXDTO.Имя))
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Обработка вспомогательных данных области.

// Устарела. Выполняет запись значения ссылочного типа, разделенных разделителем РазделительВспомогательныхДанных
// с переключением разделения сеанса на время записи.
//
// Параметры:
//  ОбъектВспомогательныхДанных - СправочникОбъект
//                              - ПланВидовХарактеристикОбъект
//                              - ДокументОбъект - объект ссылочного типа или УдалениеОбъекта.
//
Процедура ЗаписатьВспомогательныеДанные(ОбъектВспомогательныхДанных) Экспорт
	
	ОбъектВспомогательныхДанных.Записать();
	
КонецПроцедуры

// Устарела. Выполняет удаление значения ссылочного типа, разделенных разделителем РазделительВспомогательныхДанных
// с переключением разделения сеанса на время записи.
//
// Параметры:
//  ОбъектВспомогательныхДанных - СправочникОбъект
//                              - ПланВидовХарактеристикОбъект
//                              - ДокументОбъект - объект ссылочного типа.
//
Процедура УдалитьВспомогательныеДанные(ОбъектВспомогательныхДанных) Экспорт
	
	ОбъектВспомогательныхДанных.Удалить();
	
КонецПроцедуры

// Для внутреннего использования.
// Возвращаемое значение:
//  СоставОбщегоРеквизита - состав.
//
Функция ОбластьДанныхОсновныеДанныеСостав() Экспорт
	Возврат Метаданные.ОбщиеРеквизиты.ОбластьДанныхОсновныеДанные.Состав;
КонецФункции

// Для внутреннего использования.
// Возвращаемое значение:
//  Число - область данных.
//
Функция ПолучитьОбластиДанныхРезультатЗапроса() Экспорт
	Запрос = Новый Запрос();
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ОбластиДанных.ОбластьДанныхВспомогательныеДанные КАК ОбластьДанных
	|ИЗ
	|	РегистрСведений.ОбластиДанных КАК ОбластиДанных
	|ГДЕ
	|	ОбластиДанных.Статус = ЗНАЧЕНИЕ(Перечисление.СтатусыОбластейДанных.Используется)
	|УПОРЯДОЧИТЬ ПО
	|	ОбластьДанных";
	
	Результат = Запрос.Выполнить();
	
	Возврат Результат;
КонецФункции



////////////////////////////////////////////////////////////////////////////////
// Обработчики событий подсистем конфигурации.

// См. ОчередьЗаданийПереопределяемый.ПриОпределенииПсевдонимовОбработчиков.
Процедура ПриОпределенииПсевдонимовОбработчиков(СоответствиеИменПсевдонимам) Экспорт
	
	СоответствиеИменПсевдонимам.Вставить("РаботаВМоделиСервиса.ПодготовитьОбластьДанныхКИспользованию");
	
	СоответствиеИменПсевдонимам.Вставить("РаботаВМоделиСервиса.ОчиститьОбластьДанных");
	
КонецПроцедуры

// См. ОчередьЗаданийПереопределяемый.ПриОпределенииИспользованияРегламентныхЗаданий
Процедура ПриОпределенииИспользованияРегламентныхЗаданий(ТаблицаИспользования) Экспорт
	
	НоваяСтрока = ТаблицаИспользования.Добавить();
	НоваяСтрока.РегламентноеЗадание = "ОбслуживаниеОбластейДанных";
	НоваяСтрока.Использование       = Истина;
	
КонецПроцедуры

// См. ЗагрузкаДанныхИзФайлаПереопределяемый.ПриОпределенииСправочниковДляЗагрузкиДанных.
Процедура ПриОпределенииСправочниковДляЗагрузкиДанных(ЗагружаемыеСправочники) Экспорт
	
	// Загрузка в классификатор валюты запрещена.
	СтрокаТаблицы = ЗагружаемыеСправочники.Найти(Метаданные.Справочники.ОчередьЗаданийОбластейДанных.ПолноеИмя(), "ПолноеИмя");
	Если СтрокаТаблицы <> Неопределено Тогда 
		ЗагружаемыеСправочники.Удалить(СтрокаТаблицы);
	КонецЕсли;
	
КонецПроцедуры

// См. ВыгрузкаЗагрузкаДанныхПереопределяемый.ПриЗаполненииТиповИсключаемыхИзВыгрузкиЗагрузки
Процедура ПриЗаполненииТиповИсключаемыхИзВыгрузкиЗагрузки(Типы) Экспорт
	
	Типы.Добавить(Метаданные.Константы.КлючОбластиДанных);
	Типы.Добавить(Метаданные.РегистрыСведений.ОбластиДанных);
	
КонецПроцедуры

// См. РаботаВМоделиСервисаПереопределяемый.ПриВключенииРазделенияПоОбластямДанных.
Процедура ПриВключенииРазделенияПоОбластямДанных() Экспорт
	
	ПроверитьВозможностьИспользованияКонфигурацииВМоделиСервиса();
	
	РаботаВМоделиСервисаПереопределяемый.ПриВключенииРазделенияПоОбластямДанных();
	
КонецПроцедуры

// См. ПоставляемыеДанныеПереопределяемый.ПолучитьОбработчикиПоставляемыхДанных.
Процедура ПриОпределенииОбработчиковПоставляемыхДанных(Обработчики) Экспорт
	
	ЗарегистрироватьОбработчикиПоставляемыхДанных(Обработчики);
	
КонецПроцедуры

// Проверка безопасного режима разделения данных.
// Только для вызова из модуля сеанса.
//
Процедура ПриПроверкеВключенияБезопасногоРежимаРазделенияДанных() Экспорт
	
	Если БезопасныйРежим() = Ложь
		И РазделениеВключено()
		И ДоступноИспользованиеРазделенныхДанных()
		И НЕ СеансЗапущенБезРазделителей() Тогда
		
		Если НЕ БезопасныйРежимРазделенияДанных(РазделительВспомогательныхДанных()) Тогда
			
			УстановитьБезопасныйРежимРазделенияДанных(РазделительВспомогательныхДанных(), Истина);
			
		КонецЕсли;
		
		Если НЕ БезопасныйРежимРазделенияДанных(РазделительОсновныхДанных()) Тогда
			
			УстановитьБезопасныйРежимРазделенияДанных(РазделительОсновныхДанных(), Истина);
			
		КонецЕсли;
	
	КонецЕсли;
	
КонецПроцедуры

// Проверка заблокированности области данных при запуске.
// Только для вызова из СтандартныеПодсистемыСервер.ДобавитьПараметрыРаботыКлиентаПриЗапуске().
//
Процедура ПриПроверкеБлокировкиОбластиДанныхПриЗапуске(ОписаниеОшибки) Экспорт
	
	Если РазделениеВключено()
			И ДоступноИспользованиеРазделенныхДанных()
			И ОбластьДанныхЗаблокирована(ЗначениеРазделителяСеанса()) Тогда
		
		ОписаниеОшибки =
			НСтр("ru = 'Запуск приложения временно недоступен.
			           |Выполняются регламентные операции по обслуживанию приложения.
			           |
			           |Попробуйте запустить приложение через несколько минут.'");
		
	КонецЕсли;
	
КонецПроцедуры

// См. ОбновлениеИнформационнойБазыБСП.ПриДобавленииОбработчиковОбновления.
Процедура ПриДобавленииОбработчиковОбновления(Обработчики) Экспорт
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "*";
	Обработчик.Процедура = "РаботаВМоделиСервиса.КонтрольРазделителейПриОбновлении";
	Обработчик.ОбщиеДанные = Истина;
	Обработчик.ВыполнятьВГруппеОбязательных = Истина;
	Обработчик.Приоритет = 99;
	Обработчик.МонопольныйРежим = Ложь;
	
	Если РазделениеВключено() Тогда
		
		Обработчик = Обработчики.Добавить();
		Обработчик.Версия = "*";
		Обработчик.Процедура = "РаботаВМоделиСервиса.ПроверитьВозможностьИспользованияКонфигурацииВМоделиСервиса";
		Обработчик.ОбщиеДанные = Истина;
		Обработчик.ВыполнятьВГруппеОбязательных = Истина;
		Обработчик.Приоритет = 99;
		Обработчик.МонопольныйРежим = Ложь;
		
	КонецЕсли;
	
КонецПроцедуры

// См. ОбщегоНазначенияПереопределяемый.ПриДобавленииПараметровРаботыКлиентаПриЗапуске.
Процедура ПриДобавленииПараметровРаботыКлиентаПриЗапуске(Параметры) Экспорт
	
	ПриДобавленииПараметровРаботыКлиента(Параметры);
	
КонецПроцедуры

// См. ОбщегоНазначенияПереопределяемый.ПриДобавленииПараметровРаботыКлиента.
Процедура ПриДобавленииПараметровРаботыКлиента(Параметры) Экспорт
	
	Если НЕ РазделениеВключено()
		ИЛИ НЕ ДоступноИспользованиеРазделенныхДанных() Тогда
		Возврат;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ПредставлениеОбластиДанных.Значение КАК Представление
	|ИЗ
	|	Константа.ПредставлениеОбластиДанных КАК ПредставлениеОбластиДанных
	|ГДЕ
	|	ПредставлениеОбластиДанных.ОбластьДанныхВспомогательныеДанные = &ОбластьДанныхВспомогательныеДанные";
	УстановитьПривилегированныйРежим(Истина);
	Запрос.УстановитьПараметр("ОбластьДанныхВспомогательныеДанные", ЗначениеРазделителяСеанса());
	// Считаем данные условно неизменяемыми.
	Результат = Запрос.Выполнить();
	УстановитьПривилегированныйРежим(Ложь);
	Если НЕ Результат.Пустой() Тогда
		Выборка = Результат.Выбрать();
		Выборка.Следующий();
		Если СеансЗапущенБезРазделителей() Тогда
			Параметры.Вставить("ПредставлениеОбластиДанных", 
				Формат(ЗначениеРазделителяСеанса(), "ЧН=0; ЧГ=") +  " - " + Выборка.Представление);
		ИначеЕсли НЕ ПустаяСтрока(Выборка.Представление) Тогда
			Параметры.Вставить("ПредставлениеОбластиДанных", Выборка.Представление);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// См. ВыгрузкаЗагрузкаДанныхПереопределяемый.ПослеЗагрузкиДанных.
Процедура ПослеЗагрузкиДанных(Контейнер) Экспорт
	
	ПользователиСлужебный.ПослеЗагрузкиДанных(Контейнер);
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.УправлениеИтогамиИАгрегатами") Тогда
		
		МодульУправлениеИтогамиИАгрегатамиСлужебный = ОбщегоНазначения.ОбщийМодуль("УправлениеИтогамиИАгрегатамиСлужебный");
		МодульУправлениеИтогамиИАгрегатамиСлужебный.РассчитатьИтоги();
		
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

////////////////////////////////////////////////////////////////////////////////
// Подготовка областей данных

// Обновляет статус области в регистре ОбластиДанных, отправляет сообщение в менеджер сервиса.
//
// Параметры:
//  МенеджерЗаписи - РегистрСведенийМенеджерЗаписи.ОбластиДанных - менеджер записи
//  РезультатПодготовки - Строка - одна из "Успех", "ТребуетсяКонвертация", "ФатальнаяОшибка",
//    "ОшибкаУдаления", "ОбластьУдалена".
//  СообщениеОбОшибке - Строка - текст сообщения об ошибке. 
//
Процедура СменитьСтатусОбластиИУведомитьМенеджер(Знач МенеджерЗаписи, Знач РезультатПодготовки, Знач СообщениеОбОшибке)
	
	КопияМенеджера = РегистрыСведений.ОбластиДанных.СоздатьМенеджерЗаписи();
	ЗаполнитьЗначенияСвойств(КопияМенеджера, МенеджерЗаписи);
	МенеджерЗаписи = КопияМенеджера;

	ВключатьСообщениеОбОшибке = Ложь;
	
	ВызываемыйМодуль = ОбщегоНазначения.ОбщийМодуль("СообщенияКонтрольУдаленногоАдминистрированияИнтерфейс");
	Если РезультатПодготовки = "Успех" Тогда
		МенеджерЗаписи.Статус = Перечисления.СтатусыОбластейДанных.Используется;
		ТипСообщения = ВызываемыйМодуль.СообщениеОбластьДанныхПодготовлена();
	ИначеЕсли РезультатПодготовки = "ТребуетсяКонвертация" Тогда
		МенеджерЗаписи.Статус = Перечисления.СтатусыОбластейДанных.ИмпортИзФайла;
		ТипСообщения = ВызываемыйМодуль.СообщениеОшибкаПодготовкиОбластиДанныхТребуетсяКонвертация();
	ИначеЕсли РезультатПодготовки = "ОбластьУдалена" Тогда
		МенеджерЗаписи.Статус = Перечисления.СтатусыОбластейДанных.Удалена;
		ТипСообщения = ВызываемыйМодуль.СообщениеОбластьДанныхУдалена();
	ИначеЕсли РезультатПодготовки = "ФатальнаяОшибка" Тогда
		ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииПодготовкаОбластиДанных(), 
			УровеньЖурналаРегистрации.Ошибка, , , СообщениеОбОшибке);
		МенеджерЗаписи.ОшибкаОбработки = Истина;
		ТипСообщения = ВызываемыйМодуль.СообщениеОшибкаПодготовкиОбластиДанных();
		ВключатьСообщениеОбОшибке = Истина;
	ИначеЕсли РезультатПодготовки = "ОшибкаУдаления" Тогда
		МенеджерЗаписи.ОшибкаОбработки = Истина;
		ТипСообщения = ВызываемыйМодуль.СообщениеОшибкаУдаленияОбластиДанных();
		ВключатьСообщениеОбОшибке = Истина;
	Иначе
		ВызватьИсключение НСтр("ru = 'Неожиданный код возврата'");
	КонецЕсли;
	
	// Отправить сообщение о готовности области в менеджер сервиса.
	Сообщение = СообщенияВМоделиСервиса.НовоеСообщение(ТипСообщения);
	Сообщение.Body.Zone = МенеджерЗаписи.ОбластьДанныхВспомогательныеДанные;
	Если ВключатьСообщениеОбОшибке Тогда
		Сообщение.Body.ErrorDescription = СообщениеОбОшибке;
	КонецЕсли;

	НачатьТранзакцию();
	Попытка
		СообщенияВМоделиСервиса.ОтправитьСообщение(
			Сообщение,
			КонечнаяТочкаМенеджераСервиса());
		
		МенеджерЗаписи.Записать();
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Загружает данные в область из пользовательской выгрузки.
//
// Параметры:
//   ОбластьДанных - Число - номер заполняемой области.
//   ИДФайлаВыгрузки - Строка - ИД файла начальных данных.
//   СообщениеОбОшибке - Строка - возвращаемая, описание ошибки.
//
// Возвращаемое значение:
//  Строка - один из вариантов "ТребуетсяКонвертация", "Успех", "ФатальнаяОшибка".
//
Функция ПодготовитьОбластьДанныхКИспользованиюИзВыгрузки(Знач ОбластьДанных, Знач ИДФайлаВыгрузки, СообщениеОбОшибке)
	
	ИмяФайлаВыгрузки = ПолучитьФайлИзХранилищаМенеджераСервиса(ИДФайлаВыгрузки);
	
	Если ИмяФайлаВыгрузки = Неопределено Тогда
		
		СообщениеОбОшибке = НСтр("ru = 'Нет файла начальных данных для области'");
		
		Возврат "ФатальнаяОшибка";
	КонецЕсли;
	
	Если Не ОбщегоНазначения.ПодсистемаСуществует("ТехнологияСервиса.ВыгрузкаЗагрузкаОбластейДанных") Тогда
		
		ВызватьИсключениеОтсутствуетПодсистемаБТС("ТехнологияСервиса.ВыгрузкаЗагрузкаОбластейДанных");
		
	КонецЕсли;
	
	МодульВыгрузкаЗагрузкаОбластейДанных = ОбщегоНазначения.ОбщийМодуль("ВыгрузкаЗагрузкаОбластейДанных");
	
	Если Не МодульВыгрузкаЗагрузкаОбластейДанных.ВыгрузкаВАрхивеСовместимаСТекущейКонфигурацией(ИмяФайлаВыгрузки) Тогда
		Результат = "ТребуетсяКонвертация";
	Иначе
		
		МодульВыгрузкаЗагрузкаОбластейДанных.ЗагрузитьТекущуюОбластьДанныхИзАрхива(ИмяФайлаВыгрузки);
		Результат = "Успех";
		
	КонецЕсли;
	
	Попытка
		УдалитьФайлы(ИмяФайлаВыгрузки);
	Исключение
		ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииПодготовкаОбластиДанных(), 
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	Возврат Результат;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Функции определения типов объектов метаданных по полному имени объекта
// метаданных.

Функция ПроверкаТипаОбъектаМетаданныхПоПолномуИмени(Знач ПолноеИмя, Знач РусскаяЛокализация, Знач АнглийскаяЛокализация, Знач ПозицияПодстроки = 0)
	
	Подстроки = СтрРазделить(ПолноеИмя, ".");
	Если Подстроки.Количество() > ПозицияПодстроки Тогда
		ИмяТипа = Подстроки.Получить(ПозицияПодстроки);
		Возврат ИмяТипа = РусскаяЛокализация ИЛИ ИмяТипа = АнглийскаяЛокализация;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Работа с файлами

// Добавляет файл в хранилище менеджера сервиса.
//
// Параметры:
//  АдресДанныеФайл - Строка, ДвоичныеДанные, Файл - Строка/ДвоичныеДанные/Файл - Адрес временного хранилища/Данные файла/Файл.
//  ПараметрыПодключения - Структура:
//   * URL - Строка - URL сервиса. Обязательно должно присутствовать и быть заполненным.
//   * UserName - Строка - имя пользователя сервиса.
//   * Password - Строка - пароль пользователя сервиса.
//  ИмяФайла - Строка - хранимое имя файла.
//
// Возвращаемое значение:
//   УникальныйИдентификатор - идентификатор файла в хранилище.
//
Функция ПоместитьФайлВХранилище(Знач АдресДанныеФайл, Знач ПараметрыПодключения, Знач ИмяФайла = "")
	
	УдалятьВременныйФайл = Ложь;
	НачалоВыполнения = ТекущаяУниверсальнаяДата();
	
	ОписаниеПрокси = ОписаниеПроксиСервисаПередачиФайлов(ПараметрыПодключения);
	
	Описание = ПолучитьИмяФайлаСДанными(АдресДанныеФайл, ИмяФайла);
	
	Если ПустаяСтрока(Описание.Имя) Тогда
		
		Описание.Имя = ПолучитьИмяВременногоФайла();
		УдалятьВременныйФайл = Истина;
		
	КонецЕсли;
	
	СвойстваФайла = Новый Файл(Описание.Имя);
	
	ОбменЧерезФС = МожноПередаватьЧерезФСНаСервер(ОписаниеПрокси.Прокси, ОписаниеПрокси.ЕстьПоддержка2йВерсии);
	
	Если ОбменЧерезФС Тогда
		
		// Сохранить данные в файл.
		ОбщийКаталог = ФайлыБТС.ОбщийКаталогВременныхФайлов();
		ЦелевойФайл = Новый Файл(ОбщийКаталог + СвойстваФайла.Имя);
		Если ЦелевойФайл.Существует() Тогда
			// Это один и тот же файл. Его можно, не передавая, сразу читать на сервере.
			Если СвойстваФайла.ПолноеИмя = ЦелевойФайл.ПолноеИмя Тогда
				Результат = ОписаниеПрокси.Прокси.ReadFileFromFS(ЦелевойФайл.Имя, СвойстваФайла.Имя);
				РазмерИсходногоФайла = ЦелевойФайл.Размер();
				ЗаписатьВЖурналСобытиеФайловогоХранилища(
					НСтр("ru = 'Помещение'", ОбщегоНазначения.КодОсновногоЯзыка()),
					Результат,
					РазмерИсходногоФайла,
					ТекущаяУниверсальнаяДата() - НачалоВыполнения,
					ОбменЧерезФС);
				Возврат Результат;
				// Нельзя удалять, поскольку он является и источником.
			КонецЕсли;
			// Источник и приемник - разные файлы. Чтобы не затереть чужой файл, делаем приемнику уникальное имя.
			НовыйИД = Новый УникальныйИдентификатор;
			ЦелевойФайл = Новый Файл(ОбщийКаталог + НовыйИД + СвойстваФайла.Расширение);
		КонецЕсли;
		
		Попытка
			Если Описание.Данные = Неопределено Тогда
				КопироватьФайл(СвойстваФайла.ПолноеИмя, ЦелевойФайл.ПолноеИмя);
			Иначе
				Описание.Данные.Записать(ЦелевойФайл.ПолноеИмя);
			КонецЕсли;
			Результат = ОписаниеПрокси.Прокси.ReadFileFromFS(ЦелевойФайл.Имя, СвойстваФайла.Имя);
			РазмерИсходногоФайла = ЦелевойФайл.Размер();
			ЗаписатьВЖурналСобытиеФайловогоХранилища(
				НСтр("ru = 'Помещение'", ОбщегоНазначения.КодОсновногоЯзыка()),
				Результат,
				РазмерИсходногоФайла,
				ТекущаяУниверсальнаяДата() - НачалоВыполнения,
				ОбменЧерезФС);
		Исключение
			ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииДобавлениеФайлаОбменЧерезФС(),
				УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			ОбменЧерезФС = Ложь;
		КонецПопытки;
		
		УдалитьВременныеФайлы(ЦелевойФайл.ПолноеИмя);
		Если УдалятьВременныйФайл Тогда
			УдалитьВременныеФайлы(Описание.Имя)
		КонецЕсли;
		
	КонецЕсли; // ОбменЧерезФС
		
	Если НЕ ОбменЧерезФС Тогда
		
		Если Описание.Данные = Неопределено Тогда
			
			Если СвойстваФайла.Существует() Тогда
				
				КаталогСборки = Неопределено;
				ПолноеИмяФайла = СвойстваФайла.ПолноеИмя;
				
			Иначе
				
				ВызватьИсключение(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Добавление файла в хранилище. Не найден файл %1.'"),
					СвойстваФайла.ПолноеИмя));
					
			КонецЕсли;
				
		Иначе
			
			Попытка
				
				КаталогСборки = СоздатьКаталогСборки();
				ПолноеИмяФайла = КаталогСборки + СвойстваФайла.Имя;
				Описание.Данные.Записать(ПолноеИмяФайла);
				
			Исключение
				
				УдалитьВременныеФайлы(КаталогСборки);
				ВызватьИсключение;
				
			КонецПопытки;
			
		КонецЕсли;
		
		// Архивировать файл.
		Попытка
			
			ИмяФайлаАрхива = ПолучитьИмяВременногоФайла("zip");
			Архиватор = Новый ЗаписьZipФайла(ИмяФайлаАрхива,,,, УровеньСжатияZIP.Минимальный);
			Архиватор.Добавить(ПолноеИмяФайла);
			Архиватор.Записать();
			
		Исключение
			
			Если УдалятьВременныйФайл Тогда
				
				УдалитьВременныеФайлы(Описание.Имя);
				
			КонецЕсли;
			
			УдалитьВременныеФайлы(ИмяФайлаАрхива);

			Если ЗначениеЗаполнено(КаталогСборки) Тогда
				
				УдалитьВременныеФайлы(КаталогСборки);
				
			КонецЕсли;
			
			ВызватьИсключение;
				
		КонецПопытки;
		
		Если УдалятьВременныйФайл Тогда
			
			УдалитьВременныеФайлы(Описание.Имя);
			
		КонецЕсли;
		
		Если ЗначениеЗаполнено(КаталогСборки) Тогда
			
			УдалитьВременныеФайлы(КаталогСборки);
			
		КонецЕсли;
		
		РазмерБлокаПередачиФайла = ПолучитьРазмерБлокаПередачиФайла() * 1024 * 1024;
		ИдентификаторПередачи = Новый УникальныйИдентификатор;
		
		ФайлАрхива = Новый Файл(ИмяФайлаАрхива);
		РазмерФайлАрхива = ФайлАрхива.Размер();
		
		КоличествоЧастей = Окр((РазмерФайлАрхива / РазмерБлокаПередачиФайла) + 0.5, 0, РежимОкругления.Окр15как10);
		
		ПотокЧтения = Неопределено;
		
		Попытка
			
			ПотокЧтения = ФайловыеПотоки.ОткрытьДляЧтения(ИмяФайлаАрхива);
			ПотокЧтения.Перейти(0, ПозицияВПотоке.Начало);
			
			НомерЧасти = 0;
			
			Пока ПотокЧтения.ТекущаяПозиция() < РазмерФайлАрхива - 1 Цикл
				
				НомерЧасти = НомерЧасти + 1;
				Буфер = Новый БуферДвоичныхДанных(Мин(РазмерБлокаПередачиФайла, РазмерФайлАрхива - ПотокЧтения.ТекущаяПозиция()));
				ПотокЧтения.Прочитать(Буфер, 0, Буфер.Размер);
				
				КоличествоПопыток = 10;
				
				Для НомерПопытки = 1 По КоличествоПопыток Цикл
				
					Попытка
						
						Если ОписаниеПрокси.ЕстьПоддержка2йВерсии Тогда
							
							ОписаниеПрокси.Прокси.PutFilePart(ИдентификаторПередачи, НомерЧасти, ПолучитьДвоичныеДанныеИзБуфераДвоичныхДанных(Буфер), КоличествоЧастей);
							
						Иначе // 1-я версия.
							
							ОписаниеПрокси.Прокси.PutFilePart(ИдентификаторПередачи, НомерЧасти, ПолучитьДвоичныеДанныеИзБуфераДвоичныхДанных(Буфер));
							
						КонецЕсли;
						
						Прервать;
						
					Исключение
						
						Если НомерПопытки = КоличествоПопыток Тогда
							
							ВызватьИсключение;
							
						КонецЕсли;
						
					КонецПопытки;
					
				КонецЦикла;
				
			КонецЦикла;
			
		Исключение
			
			Если ПотокЧтения <> Неопределено Тогда
				
				ПотокЧтения.Закрыть();
				
			КонецЕсли;
			
			ОписаниеИсключения = ОписаниеОшибки();
			
			УдалитьВременныеФайлы(ИмяФайлаАрхива);
			
			Попытка
				
				ОписаниеПрокси.Прокси.ReleaseFile(ИдентификаторПередачи);
				
			Исключение
				
				ОписаниеИсключения = ОписаниеИсключения + Символы.ПС + ОписаниеОшибки();
				
			КонецПопытки;
			
			ВызватьИсключение ОписаниеИсключения;
			
		КонецПопытки;
		
		ПотокЧтения.Закрыть();
		УдалитьВременныеФайлы(ИмяФайлаАрхива);
		
		Если ОписаниеПрокси.ЕстьПоддержка2йВерсии Тогда
			
			Результат = ОписаниеПрокси.Прокси.SaveFileFromParts(ИдентификаторПередачи, КоличествоЧастей);
			
		Иначе // 1-я версия.
			
			Результат = Неопределено;
			ОписаниеПрокси.Прокси.SaveFileFromParts(ИдентификаторПередачи, КоличествоЧастей, Результат);
			
		КонецЕсли;
		
		ЗаписатьВЖурналСобытиеФайловогоХранилища(
			НСтр("ru = 'Помещение'", ОбщегоНазначения.КодОсновногоЯзыка()),
			Результат,
			РазмерИсходногоФайла,
			ТекущаяУниверсальнаяДата() - НачалоВыполнения,
			ОбменЧерезФС);
		
	КонецЕсли; // Не ОбменЧерезФС
	
	Возврат Результат;
	
КонецФункции

// Возвращает структуру с именем и данными файла по адресу во временном хранилище/информации в объекте Файл/двоичным
// данным.
//
// Параметры:
//  АдресДанныеФайл - Строка, ДвоичныеДанные, Файл - Строка/ДвоичныеДанные/Файл - Адрес хранилища данных файла/Данные файла/Файл.
//  ИмяФайла - Строка - имя файла. 
//
// Возвращаемое значение:
//   Структура:
//   * Данные - ДвоичныеДанные - данные файла.
//   * Имя - Строка - имя файла.
//
Функция ПолучитьИмяФайлаСДанными(Знач АдресДанныеФайл, Знач ИмяФайла = "")
	
	Если ТипЗнч(АдресДанныеФайл) = Тип("Строка") Тогда // Адрес данных файла во временном хранилище.
		Если ПустаяСтрока(АдресДанныеФайл) Тогда
			ВызватьИсключение(НСтр("ru = 'Неверный адрес хранилища.'"));
		КонецЕсли;
		ДанныеФайла = ПолучитьИзВременногоХранилища(АдресДанныеФайл);
	ИначеЕсли ТипЗнч(АдресДанныеФайл) = Тип("Файл") Тогда // Объект типа Файл.
		Если Не АдресДанныеФайл.Существует() Тогда
			ВызватьИсключение(НСтр("ru = 'Файл не найден.'"));
		КонецЕсли;
		ДанныеФайла = Неопределено;
		ИмяФайла = АдресДанныеФайл.ПолноеИмя;
	ИначеЕсли ТипЗнч(АдресДанныеФайл) = Тип("ДвоичныеДанные") Тогда // Данные файла.
		ДанныеФайла = АдресДанныеФайл;
	Иначе
		ВызватьИсключение(НСтр("ru = 'Неверный тип данных'"));
	КонецЕсли;
	
	Возврат Новый Структура("Данные, Имя", ДанныеФайла, ИмяФайла);
	
КонецФункции

// Проверяет, возможна ли передача файла через файловую систему с сервера на клиент.
//
// Параметры:
//  Прокси - WSПрокси - прокси сервиса FilesTransfer*
//  ЕстьПоддержка2йВерсии - Булево
//
// Возвращаемое значение:
//  Булево - признак.
//
Функция МожноПередаватьЧерезФСССервера(Знач Прокси, Знач ЕстьПоддержка2йВерсии)
	
	Если Не ЕстьПоддержка2йВерсии Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ИмяФайла = Прокси.WriteTestFile();
	Если ИмяФайла = "" Тогда 
		Возврат Ложь;
	КонецЕсли;
	
	Результат = ПрочитатьПробныйФайл(ИмяФайла);
	
	Прокси.DeleteTestFile(ИмяФайла);
	
	Возврат Результат;
	
КонецФункции

// Проверяет, возможна ли передача файла через файловую систему с клиента на сервер.
//
// Параметры:
//  Прокси - WSПрокси - прокси сервиса FilesTransfer*
//  ЕстьПоддержка2йВерсии - Булево
//
// Возвращаемое значение:
//  Булево - признак.
//
Функция МожноПередаватьЧерезФСНаСервер(Знач Прокси, Знач ЕстьПоддержка2йВерсии)
	
	Если Не ЕстьПоддержка2йВерсии Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ИмяФайла = ЗаписатьПробныйФайл();
	Если ИмяФайла = "" Тогда 
		Возврат Ложь;
	КонецЕсли;
	
	Результат = Прокси.ReadTestFile(ИмяФайла);
	
	ПолноеИмяФайла = ФайлыБТС.ОбщийКаталогВременныхФайлов() + ИмяФайла;
	УдалитьВременныеФайлы(ПолноеИмяФайла);
	
	Возврат Результат;
	
КонецФункции

// Создать каталог с уникальным именем для размещения частей разделяемого файла.
//
// Возвращаемое значение:
//   Строка - имя каталога.
//
Функция СоздатьКаталогСборки()
	
	КаталогСборки = ПолучитьИмяВременногоФайла();
	СоздатьКаталог(КаталогСборки);
	Возврат КаталогСборки + ПолучитьРазделительПути();
	
КонецФункции

// Читает тестовый файл с диска, сравнивая содержимое и имя: они должны совпадать.
// Файл должна удалять вызывающая сторона.
//
// Параметры:
//   ИмяФайла - Строка - без пути.
//
// Возвращаемое значение:
//   Булево - Истина, если файл успешно прочтен и содержимое совпадает с его именем.
//
Функция ПрочитатьПробныйФайл(Знач ИмяФайла)
	
	СвойстваФайла = Новый Файл(ФайлыБТС.ОбщийКаталогВременныхФайлов() + ИмяФайла);
	Если СвойстваФайла.Существует() Тогда
		Текст = Новый ЧтениеТекста(СвойстваФайла.ПолноеИмя, КодировкаТекста.ANSI);
		ТестовыйИД = Текст.Прочитать();
		Текст.Закрыть();
		Возврат ТестовыйИД = СвойстваФайла.ИмяБезРасширения;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

// Создает незаполненную структуру нужного формата.
//
// Возвращаемое значение:
//   Структура:
//   Имя - Строка - имя файла в хранилище.
//   Данные - ДвоичныеДанные - данные файла.
//    ПолноеИмя - Строка - имя файла с путем.
//
Функция СоздатьОписаниеФайла()
	
	ОписаниеФайла = Новый Структура;
	ОписаниеФайла.Вставить("Имя");
	ОписаниеФайла.Вставить("Данные");
	ОписаниеФайла.Вставить("ПолноеИмя");
	ОписаниеФайла.Вставить("ОбязательныеПараметры", "Имя"); // Обязательные к заполнению параметры.
	Возврат ОписаниеФайла;
	
КонецФункции

// Получает объект WSПрокси Web-сервиса, заданного своим базовым именем.
//
// Параметры:
//   ПараметрыПодключения - Структура:
//   * URL - Строка - URL сервиса. Обязательно должно присутствовать и быть заполненным.
//   * UserName - Строка - имя пользователя сервиса.
//   * Password - Строка - пароль пользователя сервиса.
// Возвращаемое значение:
//  Структура:
//   * Прокси - WSПрокси - прокси,
//   * ЕстьПоддержка2йВерсии - Булево - признак.
//
Функция ОписаниеПроксиСервисаПередачиФайлов(Знач ПараметрыПодключения)
	
	БазовоеИмяСервиса = "FilesTransfer";
	
	МассивПоддерживаемыхВерсий = ОбщегоНазначения.ПолучитьВерсииИнтерфейса(ПараметрыПодключения, "СервисПередачиФайлов");
	Если МассивПоддерживаемыхВерсий.Найти("1.0.2.1") = Неопределено Тогда
		ЕстьПоддержка2йВерсии = Ложь;
		ВерсияИнтерфейса = "1.0.1.1"
	Иначе
		ЕстьПоддержка2йВерсии = Истина;
		ВерсияИнтерфейса = "1.0.2.1";
	КонецЕсли;
	
	Если ПараметрыПодключения.Свойство("UserName")
		И ЗначениеЗаполнено(ПараметрыПодключения.UserName) Тогда
		
		ИмяПользователя = ПараметрыПодключения.UserName;
		ПарольПользователя = ПараметрыПодключения.Password;
	Иначе
		ИмяПользователя = Неопределено;
		ПарольПользователя = Неопределено;
	КонецЕсли;
	
	Если ВерсияИнтерфейса = Неопределено Или ВерсияИнтерфейса = "1.0.1.1" Тогда // 1-я версия.
		ИмяСервиса = БазовоеИмяСервиса;
	Иначе // Версии 2 и выше.
		ИмяСервиса = БазовоеИмяСервиса + "_" + СтрЗаменить(ВерсияИнтерфейса, ".", "_");
	КонецЕсли;
	
	АдресСервиса = ПараметрыПодключения.URL + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку("/ws/%1?wsdl", ИмяСервиса);
	
	ПараметрыПодключения = ОбщегоНазначения.ПараметрыПодключенияWSПрокси();
	ПараметрыПодключения.АдресWSDL = АдресСервиса;
	ПараметрыПодключения.URIПространстваИмен = "http://www.1c.ru/SaaS/1.0/WS";
	ПараметрыПодключения.ИмяСервиса = ИмяСервиса;
	ПараметрыПодключения.ИмяПользователя = ИмяПользователя;
	ПараметрыПодключения.Пароль = ПарольПользователя;
	ПараметрыПодключения.Таймаут = 600;
	Прокси = ОбщегоНазначения.СоздатьWSПрокси(ПараметрыПодключения);
	
	Возврат Новый Структура("Прокси, ЕстьПоддержка2йВерсии", Прокси, ЕстьПоддержка2йВерсии);
		
КонецФункции

Процедура ЗаписатьВЖурналСобытиеФайловогоХранилища(Знач Событие,
	Знач ИдФайла, Знач Размер, Знач Длительность, Знач ПередачаЧерезФайловуюСистему)
	
	ДанныеСобытия = Новый Структура;
	ДанныеСобытия.Вставить("ИдФайла", ИдФайла);
	ДанныеСобытия.Вставить("Размер", Размер);
	ДанныеСобытия.Вставить("Длительность", Длительность);
	
	Если ПередачаЧерезФайловуюСистему Тогда
		ДанныеСобытия.Вставить("Транспорт", "file");
	Иначе
		ДанныеСобытия.Вставить("Транспорт", "ws");
	КонецЕсли;
	
	ЗаписьЖурналаРегистрации(
		НСтр("ru = 'Хранилище файлов'", ОбщегоНазначения.КодОсновногоЯзыка()) + "." + Событие,
		УровеньЖурналаРегистрации.Информация,
		,
		,
		ОбщегоНазначения.ЗначениеВСтрокуXML(ДанныеСобытия));
	
КонецПроцедуры

/////////////////////////////////////////////////////////////////////////////////
// Временные файлы

// Удалить файл(ы) на диске.
// Если в качестве имени файла задана маска с путем, разделить его на путь и маску.
//
Процедура УдалитьВременныеФайлы(Знач ИмяФайла)
	
	Попытка
		Если СтрЗаканчиваетсяНа(ИмяФайла, "*") Тогда // Маска.
			Индекс = СтрНайти(ИмяФайла, ПолучитьРазделительПути(), НаправлениеПоиска.СКонца);
			Если Индекс > 0 Тогда
				ПутьКФайлу = Лев(ИмяФайла, Индекс - 1);
				МаскаФайла = Сред(ИмяФайла, Индекс + 1);
				Если НайтиФайлы(ПутьКФайлу, МаскаФайла, Ложь).Количество() > 0 Тогда
					УдалитьФайлы(ПутьКФайлу, МаскаФайла);
				КонецЕсли;
			КонецЕсли;
		Иначе
			СвойстваФайла = Новый Файл(ИмяФайла);
			Если СвойстваФайла.Существует() Тогда
				СвойстваФайла.УстановитьТолькоЧтение(Ложь); // Снять атрибут.
				УдалитьФайлы(СвойстваФайла.ПолноеИмя);
			КонецЕсли;
		КонецЕсли;
	Исключение
		ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииУдалениеВременногоФайла(),
			УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		Возврат;
	КонецПопытки;
	
КонецПроцедуры

/////////////////////////////////////////////////////////////////////////////////
// Сериализация

Функция ЗаписатьЗначениеВСтроку(Знач Значение)
	
	Запись = Новый ЗаписьXML;
	Запись.УстановитьСтроку();
	
	Если ТипЗнч(Значение) = Тип("ОбъектXDTO") Тогда
		ФабрикаXDTO.ЗаписатьXML(Запись, Значение, , , , НазначениеТипаXML.Явное);
	Иначе
		СериализаторXDTO.ЗаписатьXML(Запись, Значение, НазначениеТипаXML.Явное);
	КонецЕсли;
	
	Возврат Запись.Закрыть();
		
КонецФункции

// Отражает, является ли данный тип сериализуемым.
//
// Параметры:
//  СтруктурныйТип - Тип
//
// Возвращаемое значение:
//  Булево - признак.
//
Функция СериализуемыйСтруктурныйТип(СтруктурныйТип);
	
	МассивСериализуемыхТипов = РаботаВМоделиСервисаПовтИсп.СериализуемыеСтруктурныеТипы();
	
	Для Каждого СериализуемыйТип Из МассивСериализуемыхТипов Цикл 
		Если СтруктурныйТип = СериализуемыйТип Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
		
КонецФункции

// Получает XDTO-представление объекта структурного типа.
//
// Параметры:
//   ЗначениеСтруктурногоТипа - Массив из Структура
//                            - Массив из Соответствие - или их фиксированные аналоги.
//
// Возвращаемое значение:
//   ОбъектXDTO - XDTO-представление объекта структурного типа.
//
Функция СтруктурныйОбъектВОбъектXDTO(Знач ЗначениеСтруктурногоТипа)
	
	СтруктурныйТип = ТипЗнч(ЗначениеСтруктурногоТипа);
	
	Если Не СериализуемыйСтруктурныйТип(СтруктурныйТип) Тогда
		СообщениеОбОшибке = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Тип %1 не является структурным или его сериализация в настоящее время не поддерживается.'"),
			СтруктурныйТип);
		ВызватьИсключение(СообщениеОбОшибке);
	КонецЕсли;
	
	XMLТипЗначения = СериализаторXDTO.XMLТипЗнч(ЗначениеСтруктурногоТипа);
	ТипСтруктура = ФабрикаXDTO.Тип(XMLТипЗначения);
	СтруктураXDTO = ФабрикаXDTO.Создать(ТипСтруктура);
	
	// Перебор допустимых структурных типов.
	
	Если СтруктурныйТип = Тип("Структура") Или СтруктурныйТип = Тип("ФиксированнаяСтруктура") Тогда
		
		ТипСвойство = ТипСтруктура.Свойства.Получить("Property").Тип;
		
		Для Каждого КлючИЗначение Из ЗначениеСтруктурногоТипа Цикл
			Свойство = ФабрикаXDTO.Создать(ТипСвойство);
			Свойство.name = КлючИЗначение.Ключ;
			Свойство.Value = ЗначениеТипаВЗначениеXDTO(КлючИЗначение.Значение);
			СвойстваСписок = СтруктураXDTO.Property; // СписокXDTO
			СвойстваСписок.Добавить(Свойство);
		КонецЦикла;
		
	ИначеЕсли СтруктурныйТип = Тип("Массив") Или СтруктурныйТип = Тип("ФиксированныйМассив") Тогда 
		
		Для Каждого ЗначениеЭлемента Из ЗначениеСтруктурногоТипа Цикл
			ЗначенияСписок = СтруктураXDTO.Value; // СписокXDTO
			ЗначенияСписок.Добавить(ЗначениеТипаВЗначениеXDTO(ЗначениеЭлемента));
		КонецЦикла;
		
	ИначеЕсли СтруктурныйТип = Тип("Соответствие") Или СтруктурныйТип = Тип("ФиксированноеСоответствие") Тогда
		
		Для Каждого КлючИЗначение Из ЗначениеСтруктурногоТипа Цикл
			КлючЗначениеСписок = СтруктураXDTO.pair; // СписокXDTO
			КлючЗначениеСписок.Добавить(СтруктурныйОбъектВОбъектXDTO(КлючИЗначение));
		КонецЦикла;
	
	ИначеЕсли СтруктурныйТип = Тип("КлючИЗначение")	Тогда	
		
		СтруктураXDTO.key = ЗначениеТипаВЗначениеXDTO(ЗначениеСтруктурногоТипа.Ключ);
		СтруктураXDTO.value = ЗначениеТипаВЗначениеXDTO(ЗначениеСтруктурногоТипа.Значение);
		
	ИначеЕсли СтруктурныйТип = Тип("ТаблицаЗначений") Тогда
		
		XDTOТипКолонкаТЗ = ТипСтруктура.Свойства.Получить("column").Тип;
		
		Для Каждого Колонка Из ЗначениеСтруктурногоТипа.Колонки Цикл
			
			КолонкаXDTO = ФабрикаXDTO.Создать(XDTOТипКолонкаТЗ);
			
			КолонкаXDTO.Name = ЗначениеТипаВЗначениеXDTO(Колонка.Имя);
			КолонкаXDTO.ValueType = СериализаторXDTO.ЗаписатьXDTO(Колонка.ТипЗначения);
			КолонкаXDTO.Title = ЗначениеТипаВЗначениеXDTO(Колонка.Заголовок);
			КолонкаXDTO.Width = ЗначениеТипаВЗначениеXDTO(Колонка.Ширина);
			
			КолонкиСписок = СтруктураXDTO.column; // СписокXDTO
			КолонкиСписок.Добавить(КолонкаXDTO);
			
		КонецЦикла;
		
		XDTOТипИндексТЗ = ТипСтруктура.Свойства.Получить("index").Тип;
		
		Для Каждого Индекс Из ЗначениеСтруктурногоТипа.Индексы Цикл
			
			ИндексXDTO = ФабрикаXDTO.Создать(XDTOТипИндексТЗ);
			
			Для Каждого ПолеИндекса Из Индекс Цикл
				КолонкаСписок = ИндексXDTO.column; // СписокXDTO
				КолонкаСписок.Добавить(ЗначениеТипаВЗначениеXDTO(ПолеИндекса));
			КонецЦикла;
			
			ИндексСписок = СтруктураXDTO.index; // СписокXDTO
			ИндексСписок.Добавить(ИндексXDTO);
			
		КонецЦикла;
		
		XDTOТипСтрокаТЗ = ТипСтруктура.Свойства.Получить("row").Тип;
		
		Для Каждого СтрокаТЗ Из ЗначениеСтруктурногоТипа Цикл
			
			СтрокаXDTO = ФабрикаXDTO.Создать(XDTOТипСтрокаТЗ);
			
			Для Каждого ЗначениеКолонки Из СтрокаТЗ Цикл
				ЗначениеСписок = СтрокаXDTO.value; // СписокXDTO
				ЗначениеСписок.Добавить(ЗначениеТипаВЗначениеXDTO(ЗначениеКолонки));
			КонецЦикла;
			
			СтрокаТаблицыСписок = СтруктураXDTO.row; // СписокXDTO
			СтрокаТаблицыСписок.Добавить(СтрокаXDTO);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат СтруктураXDTO;
	
КонецФункции

// Получает объект структурного типа из XDTO-объекта.
//
// Параметры:
//  ОбъектXDTO - ОбъектXDTO - объект.
//
// Возвращаемое значение:
//  Массив
//  Структура
//  Соответствие
//  ФиксированныйМассив
//  ФиксированнаяСтруктура
//  ФиксированноеСоответствие - структурный объект.
//
Функция ОбъектXDTOВСтруктурныйОбъект(ОбъектXDTO)
	
	ТипДанныхXML = Новый ТипДанныхXML(ОбъектXDTO.Тип().Имя, ОбъектXDTO.Тип().UriПространстваИмен);
	Если ВозможностьЧтенияТипаДанныхXML(ТипДанныхXML) Тогда
		СтруктурныйТип = СериализаторXDTO.ИзXMLТипа(ТипДанныхXML);
	Иначе
		Возврат ОбъектXDTO;
	КонецЕсли;
	
	Если СтруктурныйТип = Тип("Строка") Тогда
		Возврат "";
	КонецЕсли;
	
	Если Не СериализуемыйСтруктурныйТип(СтруктурныйТип) Тогда
		СообщениеОбОшибке = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Тип %1 не является структурным или его сериализация в настоящее время не поддерживается.'"),
			СтруктурныйТип);
		ВызватьИсключение(СообщениеОбОшибке);
	КонецЕсли;
	
	Если СтруктурныйТип = Тип("Структура")	Или СтруктурныйТип = Тип("ФиксированнаяСтруктура") Тогда
		
		СтруктурныйОбъект = Новый Структура;
		
		Для Каждого Свойство Из ОбъектXDTO.Property Цикл
			СтруктурныйОбъект.Вставить(Свойство.name, ЗначениеXDTOВЗначениеТипа(Свойство.Value));          
		КонецЦикла;
		
		Если СтруктурныйТип = Тип("Структура") Тогда
			Возврат СтруктурныйОбъект;
		Иначе 
			Возврат Новый ФиксированнаяСтруктура(СтруктурныйОбъект);
		КонецЕсли;
		
	ИначеЕсли СтруктурныйТип = Тип("Массив") Или СтруктурныйТип = Тип("ФиксированныйМассив") Тогда 
		
		СтруктурныйОбъект = Новый Массив;
		
		Для Каждого ЭлементМассива Из ОбъектXDTO.Value Цикл
			СтруктурныйОбъект.Добавить(ЗначениеXDTOВЗначениеТипа(ЭлементМассива));          
		КонецЦикла;
		
		Если СтруктурныйТип = Тип("Массив") Тогда
			Возврат СтруктурныйОбъект;
		Иначе 
			Возврат Новый ФиксированныйМассив(СтруктурныйОбъект);
		КонецЕсли;
		
	ИначеЕсли СтруктурныйТип = Тип("Соответствие") Или СтруктурныйТип = Тип("ФиксированноеСоответствие") Тогда
		
		СтруктурныйОбъект = Новый Соответствие;
		
		Для Каждого КлючИЗначениеXDTO Из ОбъектXDTO.pair Цикл
			КлючИЗначение = ОбъектXDTOВСтруктурныйОбъект(КлючИЗначениеXDTO);
			СтруктурныйОбъект.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
		КонецЦикла;
		
		Если СтруктурныйТип = Тип("Соответствие") Тогда
			Возврат СтруктурныйОбъект;
		Иначе 
			Возврат Новый ФиксированноеСоответствие(СтруктурныйОбъект);
		КонецЕсли;
	
	ИначеЕсли СтруктурныйТип = Тип("КлючИЗначение")	Тогда	
		
		СтруктурныйОбъект = Новый Структура("Ключ, Значение");
		СтруктурныйОбъект.Ключ = ЗначениеXDTOВЗначениеТипа(ОбъектXDTO.key);
		СтруктурныйОбъект.Значение = ЗначениеXDTOВЗначениеТипа(ОбъектXDTO.value);
		
		Возврат СтруктурныйОбъект;
		
	ИначеЕсли СтруктурныйТип = Тип("ТаблицаЗначений") Тогда
		
		СтруктурныйОбъект = Новый ТаблицаЗначений;
		
		Для Каждого Колонка Из ОбъектXDTO.column Цикл
			
			СтруктурныйОбъект.Колонки.Добавить(
				ЗначениеXDTOВЗначениеТипа(Колонка.Name), 
				СериализаторXDTO.ПрочитатьXDTO(Колонка.ValueType), 
				ЗначениеXDTOВЗначениеТипа(Колонка.Title), 
				ЗначениеXDTOВЗначениеТипа(Колонка.Width));
				
		КонецЦикла;
		Для Каждого Индекс Из ОбъектXDTO.index Цикл
			
			ИндексСтрокой = "";
			Для Каждого ПолеИндекса Из Индекс.column Цикл
				ИндексСтрокой = ИндексСтрокой + ПолеИндекса + ", ";
			КонецЦикла;
			ИндексСтрокой = СокрЛП(ИндексСтрокой);
			Если СтрДлина(ИндексСтрокой) > 0 Тогда
				ИндексСтрокой = Лев(ИндексСтрокой, СтрДлина(ИндексСтрокой) - 1);
			КонецЕсли;
			
			СтруктурныйОбъект.Индексы.Добавить(ИндексСтрокой);
		КонецЦикла;
		Для Каждого СтрокаXDTO Из ОбъектXDTO.row Цикл
			
			СтрокаТЗ = СтруктурныйОбъект.Добавить();
			
			ЧислоКолонок = СтруктурныйОбъект.Колонки.Количество();
			Для Индекс = 0 По ЧислоКолонок - 1 Цикл 
				КолонкаТаблицы = СтруктурныйОбъект.Колонки[Индекс]; // КолонкаТаблицыЗначений
				СтрокаТЗ[КолонкаТаблицы.Имя] = ЗначениеXDTOВЗначениеТипа(СтрокаXDTO.value[Индекс]);
			КонецЦикла;
			
		КонецЦикла;
		
		Возврат СтруктурныйОбъект;
		
	КонецЕсли;
	
КонецФункции

Функция ВозможностьЧтенияТипаДанныхXML(Знач ТипДанныхXML)
	
	Запись = Новый ЗаписьXML;
	Запись.УстановитьСтроку();
	Запись.ЗаписатьНачалоЭлемента("Dummy");
	Запись.ЗаписатьСоответствиеПространстваИмен("xsi", "http://www.w3.org/2001/XMLSchema-instance");
	Запись.ЗаписатьСоответствиеПространстваИмен("ns1", ТипДанныхXML.URIПространстваИмен);
	Запись.ЗаписатьАтрибут("xsi:type", "ns1:" + ТипДанныхXML.ИмяТипа);
	Запись.ЗаписатьКонецЭлемента();
	
	Строка = Запись.Закрыть();
	
	Чтение = Новый ЧтениеXML;
	Чтение.УстановитьСтроку(Строка);
	Чтение.ПерейтиКСодержимому();
	
	Возврат СериализаторXDTO.ВозможностьЧтенияXML(Чтение);
	
КонецФункции

// Получает значение простейшего типа в контексте XDTO.
//
// Параметры:
//   ЗначениеТипа - Произвольный - значение произвольного типа.
//
// Возвращаемое значение:
//   ОбъектXDTO, ЗначениеXDTO - тип значения.
//
Функция ЗначениеТипаВЗначениеXDTO(Знач ЗначениеТипа)
	
	Если ЗначениеТипа = Неопределено
		Или ТипЗнч(ЗначениеТипа) = Тип("ОбъектXDTO")
		Или ТипЗнч(ЗначениеТипа) = Тип("ЗначениеXDTO") Тогда
		
		Возврат ЗначениеТипа;
		
	Иначе
		
		Если ТипЗнч(ЗначениеТипа) = Тип("Строка") Тогда
			ТипXDTO = ФабрикаXDTO.Тип("http://www.w3.org/2001/XMLSchema", "string")
		Иначе
			ТипXML = СериализаторXDTO.XMLТипЗнч(ЗначениеТипа);
			ТипXDTO = ФабрикаXDTO.Тип(ТипXML);
		КонецЕсли;
		
		Если ТипЗнч(ТипXDTO) = Тип("ТипОбъектаXDTO") Тогда // Значение структурного типа.
			Возврат СтруктурныйОбъектВОбъектXDTO(ЗначениеТипа);
		Иначе
			Возврат ФабрикаXDTO.Создать(ТипXDTO, ЗначениеТипа); // Например, UUID.
		КонецЕсли;
		
	КонецЕсли;
	
КонецФункции

// Получает платформенный аналог значения XDTO-типа.
//
// Параметры:
//   ЗначениеXDTO - ЗначениеXDTO -значение произвольного XDTO-типа.
//
// Возвращаемое значение:
//  Произвольный - значение.
//
Функция ЗначениеXDTOВЗначениеТипа(ЗначениеXDTO)
	
	Если ТипЗнч(ЗначениеXDTO) = Тип("ЗначениеXDTO") Тогда
		Возврат ЗначениеXDTO.Значение;
	ИначеЕсли ТипЗнч(ЗначениеXDTO) = Тип("ОбъектXDTO") Тогда
		Возврат ОбъектXDTOВСтруктурныйОбъект(ЗначениеXDTO);
	Иначе
		Возврат ЗначениеXDTO;
	КонецЕсли;
	
КонецФункции

// Заполняет область поставляемыми данными при подготовке к использованию.
//
// Параметры:
//   ОбластьДанных - Число - номер заполняемой области.
//   ИДФайлаВыгрузки - УникальныйИдентификатор - ид файла начальных данных.
//   Вариант - Строка - вариант начальных данных.
//   РежимИспользования - демо или рабочий.
//
// Возвращаемое значение:
//  Строка - один из вариантов "Успех", "ФатальнаяОшибка".
//
Функция ЗагрузитьОбластьИзПоставляемыхДанных(Знач ОбластьДанных, Знач ИДФайлаВыгрузки, Знач Вариант, СообщениеОФатальнойОшибке)
	
	Если НЕ Пользователи.ЭтоПолноправныйПользователь(, Истина) Тогда
		ВызватьИсключение(НСтр("ru = 'Недостаточно прав для выполнения операции'"));
	КонецЕсли;
	
	Фильтр = Новый Массив();
	Фильтр.Добавить(Новый Структура("Код, Значение", "ИмяКонфигурации", Метаданные.Имя));
	Фильтр.Добавить(Новый Структура("Код, Значение", "ВерсияКонфигурации", Метаданные.Версия));
	Фильтр.Добавить(Новый Структура("Код, Значение", "Вариант", Вариант));
	Фильтр.Добавить(Новый Структура("Код, Значение", "Режим", 
		?(Константы.РежимИспользованияИнформационнойБазы.Получить() 
			= Перечисления.РежимыИспользованияИнформационнойБазы.Демонстрационный, 
			"Демонстрационный", "Рабочий")));

	Дескрипторы = ПоставляемыеДанные.ДескрипторыПоставляемыхДанныхИзМенеджера("ЭталонОбластиДанных", Фильтр);
	
	Если Дескрипторы.Descriptor.Количество() = 0 Тогда
		СообщениеОФатальнойОшибке = 
		НСтр("ru = 'В менеджере сервиса нет файла начальных данных для текущей версии конфигурации.'");
		Возврат "ФатальнаяОшибка";
	КонецЕсли;
	
	Идентификатор = Дескрипторы.Descriptor[0].FileGUID;
	
	ДвоичныеДанныеПоставляемыхДанных = ПоставляемыеДанные.ПоставляемыеДанныеИзКэша(Идентификатор);
	Если ЗначениеЗаполнено(ДвоичныеДанныеПоставляемыхДанных) Тогда	
		ИмяФайлаВыгрузки = ПолучитьИмяВременногоФайла();
		ДвоичныеДанныеПоставляемыхДанных.Записать(ИмяФайлаВыгрузки);	
	Иначе	
		ИмяФайлаВыгрузки = ПолучитьФайлИзХранилищаМенеджераСервиса(Идентификатор);			
		Если ИмяФайлаВыгрузки = Неопределено Тогда
			СообщениеОФатальнойОшибке = 
			НСтр("ru = 'В менеджере сервиса больше нет требуемого файла начальных данных, вероятно он был заменен. Область не может быть подготовлена.'");
			Возврат "ФатальнаяОшибка";
		КонецЕсли;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если Не ОбщегоНазначения.ПодсистемаСуществует("ТехнологияСервиса.ВыгрузкаЗагрузкаОбластейДанных") Тогда
		
		ВызватьИсключениеОтсутствуетПодсистемаБТС("ТехнологияСервиса.ВыгрузкаЗагрузкаОбластейДанных");
		
	КонецЕсли;
	
	МодульВыгрузкаЗагрузкаОбластейДанных = ОбщегоНазначения.ОбщийМодуль("ВыгрузкаЗагрузкаОбластейДанных");
	
	Попытка
		
		ЗагружатьПользователейИБ = Ложь;
		СвернутьПользователей = (Не Константы.РежимИспользованияИнформационнойБазы.Получить() = Перечисления.РежимыИспользованияИнформационнойБазы.Демонстрационный);
		МодульВыгрузкаЗагрузкаОбластейДанных.ЗагрузитьТекущуюОбластьДанныхИзАрхива(ИмяФайлаВыгрузки, ЗагружатьПользователейИБ, СвернутьПользователей);
		
	Исключение
		
		ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииКопированиеОбластиДанных(), 
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		Попытка
			УдалитьФайлы(ИмяФайлаВыгрузки);
		Исключение
			ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииКопированиеОбластиДанных(), 
				УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		КонецПопытки;
		
		ВызватьИсключение;
	КонецПопытки;
	
	Попытка
		УдалитьФайлы(ИмяФайлаВыгрузки);
	Исключение
		ЗаписьЖурналаРегистрации(СобытиеЖурналаРегистрацииКопированиеОбластиДанных(), 
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
	Возврат "Успех";

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Контроль неразделенных данных.

// Вызывается при проверке доступности неразделенных данных для записи.
//
Процедура КонтрольНеразделенныхДанныхПриЗаписи(Знач Источник)
	
	Если РазделениеВключено() И ДоступноИспользованиеРазделенныхДанных() Тогда
		
		ПредставлениеИсключения = НСтр("ru = 'Нарушение прав доступа.'", ОбщегоНазначения.КодОсновногоЯзыка());
		
		ЗаписьЖурналаРегистрации(
			ПредставлениеИсключения,
			УровеньЖурналаРегистрации.Ошибка,
			Источник.Метаданные());
		
		ВызватьИсключение ПредставлениеИсключения;
		
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обработка вспомогательных данных области.

////////////////////////////////////////////////////////////////////////////////
// ОБРАБОТЧИКИ ПОЛУЧЕНИЯ ПОСТАВЛЯЕМЫХ ДАННЫХ

Процедура ОбработатьПоставляемыйЭталонКонфигурации(Знач Дескриптор, Знач ПутьКФайлу)
	
	Если ЗначениеЗаполнено(ПутьКФайлу) Тогда
		
		ПоставляемыеДанные.СохранитьПоставляемыеДанныеВКэш(Дескриптор, ПутьКФайлу);
		
		УдалитьНеактуальныеЭталоныОбластейДанных(Метаданные.Версия);
		
	Иначе
		
		Фильтр = Новый Массив;
		Для каждого Характеристика Из Дескриптор.Properties.Property Цикл
			Если Характеристика.IsKey Тогда
				Фильтр.Добавить(Новый Структура("Код, Значение", Характеристика.Code, Характеристика.Value));
			КонецЕсли;
		КонецЦикла;

		Для каждого Ссылка Из ПоставляемыеДанные.СсылкиПоставляемыхДанныхИзКэша(Дескриптор.DataType, Фильтр) Цикл
		
			ПоставляемыеДанные.УдалитьПоставляемыеДанныеИзКэша(Ссылка);
		
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

// Удаляет неактуальные эталоны областей данных: те эталоны, версия которых меньше указанной (актуальной).
//
// Параметры:
//  АктуальнаяВерсияКонфигурации - Строка - актуальная версия конфигурации.
//
Процедура УдалитьНеактуальныеЭталоныОбластейДанных(АктуальнаяВерсияКонфигурации)
	
	Запрос = Новый Запрос(
		"ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	ПоставляемыеДанныеХарактеристикиДанных.Ссылка.Ссылка КАК ПоставляемыеДанные,
		|	ВЫРАЗИТЬ(ПоставляемыеДанныеХарактеристикиДанных.Значение КАК СТРОКА(150)) КАК ВерсияКонфигурации
		|ИЗ
		|	Справочник.ПоставляемыеДанные.ХарактеристикиДанных КАК ПоставляемыеДанныеХарактеристикиДанных
		|ГДЕ
		|	ПоставляемыеДанныеХарактеристикиДанных.Характеристика = ""ВерсияКонфигурации""
		|	И ПоставляемыеДанныеХарактеристикиДанных.Ссылка.ВидДанных = ""ЭталонОбластиДанных""");
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Если ОбщегоНазначенияКлиентСервер.СравнитьВерсии(АктуальнаяВерсияКонфигурации, Выборка.ВерсияКонфигурации) > 0 Тогда
			ПоставляемыеДанные.УдалитьПоставляемыеДанныеИзКэша(Выборка.ПоставляемыеДанные);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры


////////////////////////////////////////////////////////////////////////////////
// ОБРАБОТЧИКИ ОБНОВЛЕНИЯ ИНФОРМАЦИОННОЙ БАЗЫ

// Выполняет контроль структуры метаданных по критерию недоступности неразделенных данных
// для записи из сеансов с включенным разделением.
// 
// Возвращаемое значение:
//  Неопределено - если все хорошо.
//  Структура:
//    * ОбъектыМетаданных - ОбъектМетаданных - объект метаданных.
//    * ТекстИсключения - Строка
// 
Функция КонтрольНеразделенныхДанныхПриОбновлении(ВызыватьИсключение = Истина) Экспорт
	
	ПравилаКонтроляМетаданных = Новый Соответствие;
	
	ПравилаКонтроляМетаданных.Вставить(Метаданные.Константы, "КонстантаМенеджерЗначения.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.Справочники, "СправочникОбъект.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.Документы, "ДокументОбъект.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.БизнесПроцессы, "БизнесПроцессОбъект.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.Задачи, "ЗадачаОбъект.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.ПланыВидовРасчета, "ПланВидовРасчетаОбъект.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.ПланыВидовХарактеристик, "ПланВидовХарактеристикОбъект.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.ПланыОбмена, "ПланОбменаОбъект.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.ПланыСчетов, "ПланСчетовОбъект.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.РегистрыБухгалтерии, "РегистрБухгалтерииНаборЗаписей.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.РегистрыНакопления, "РегистрНакопленияНаборЗаписей.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.РегистрыРасчета, "РегистрРасчетаНаборЗаписей.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.РегистрыСведений, "РегистрСведенийНаборЗаписей.%1");
	
	Исключения = Новый Массив();
	
	Исключения.Добавить(Метаданные.РегистрыСведений.КэшПрограммныхИнтерфейсов);
	Исключения.Добавить(Метаданные.Константы.БлокировкаОтправкиБыстрыхСообщений);
	Исключения.Добавить(Метаданные.РегистрыСведений.БезопасноеХранилищеДанных);
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ОбменДанными") Тогда
		Исключения.Добавить(Метаданные.РегистрыСведений.Найти("УдалитьНастройкиТранспортаОбмена"));
		Исключения.Добавить(Метаданные.РегистрыСведений.Найти("СостоянияОбменовДанными"));
		Исключения.Добавить(Метаданные.РегистрыСведений.Найти("СостоянияУспешныхОбменовДанными"));
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ОценкаПроизводительности") Тогда
		Исключения.Добавить(Метаданные.Справочники.Найти("КлючевыеОперации"));
		Исключения.Добавить(Метаданные.Справочники.Найти("ПрофилиКлючевыхОпераций"));
		Исключения.Добавить(Метаданные.РегистрыСведений.Найти("ЗамерыВремени"));
		Исключения.Добавить(Метаданные.РегистрыСведений.Найти("ЗамерыВремениТехнологические"));
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ЦентрМониторинга") Тогда
		Исключения.Добавить(Метаданные.РегистрыСведений.Найти("ДампыПлатформы"));
		Исключения.Добавить(Метаданные.РегистрыСведений.Найти("ОперацииСтатистики"));
		Исключения.Добавить(Метаданные.РегистрыСведений.Найти("КомментарииСтатистики"));
		Исключения.Добавить(Метаданные.РегистрыСведений.Найти("ОбластиСтатистики"));
		Исключения.Добавить(Метаданные.РегистрыСведений.Найти("КомментарииОперацииСтатистики"));
		Исключения.Добавить(Метаданные.РегистрыСведений.Найти("БуферОперацийСтатистики"));
		Исключения.Добавить(Метаданные.РегистрыСведений.Найти("ЗамерыОперацииСтатистики"));
		Исключения.Добавить(Метаданные.РегистрыСведений.Найти("ЗамерыКомментарииСтатистики"));
		Исключения.Добавить(Метаданные.РегистрыСведений.Найти("ЗамерыОбластиСтатистики"));
		Исключения.Добавить(Метаданные.РегистрыСведений.Найти("СтатистикаКонфигурации"));
		Исключения.Добавить(Метаданные.РегистрыСведений.Найти("ПакетыДляОтправки"));
        Исключения.Добавить(Метаданные.РегистрыСведений.Найти("ЗамерыСтатистики"));
	КонецЕсли;
	
	ИнтеграцияПодсистемБТС.ПриОпределенииИсключенийНеразделенныхДанных(Исключения);
	
	СтандартныеРазделители = Новый Массив; // Массив Из ОбъектМетаданныхОбщийРеквизит
	СтандартныеРазделители.Добавить(Метаданные.ОбщиеРеквизиты.ОбластьДанныхОсновныеДанные);
	СтандартныеРазделители.Добавить(Метаданные.ОбщиеРеквизиты.ОбластьДанныхВспомогательныеДанные);
	
	КонтрольныеПроцедуры = Новый Массив;
	КонтрольныеПроцедуры.Добавить(Метаданные.ПодпискиНаСобытия.КонтрольНеразделенныхНаборовЗаписейПриЗаписи.Обработчик);
	КонтрольныеПроцедуры.Добавить(Метаданные.ПодпискиНаСобытия.КонтрольНеразделенныхОбъектовПриЗаписи.Обработчик);
	КонтрольныеПроцедуры.Добавить(Метаданные.ПодпискиНаСобытия.КонтрольНеразделенныхНаборовЗаписейПриЗаписиТехнологияСервиса.Обработчик);
	КонтрольныеПроцедуры.Добавить(Метаданные.ПодпискиНаСобытия.КонтрольНеразделенныхОбъектовПриЗаписиТехнологияСервиса.Обработчик);
	
	КонтролирующиеПодписки = Новый Массив; // Массив Из ОбъектМетаданныхПодпискаНаСобытие
	Для Каждого ПодпискаНаСобытие Из Метаданные.ПодпискиНаСобытия Цикл
		Если КонтрольныеПроцедуры.Найти(ПодпискаНаСобытие.Обработчик) <> Неопределено Тогда
			КонтролирующиеПодписки.Добавить(ПодпискаНаСобытие);
		КонецЕсли;
	КонецЦикла;
	
	НарушенияКонтроляВключенияНеразделенныхДанныхВКонтролирующиеПодписки = Новый Массив();
	НарушенияКонтроляРазделенияОбъектовНесколькимиРазделителями = Новый Массив();
	ОбъектыМетаданныхСНарушениями = Новый Массив;
	
	Для Каждого ПравилоКонтроляМетаданных Из ПравилаКонтроляМетаданных Цикл
		
		КонтролируемыеОбъектыМетаданных = ПравилоКонтроляМетаданных.Ключ; // Массив Из ОбъектМетаданных
		КонструкторТипаОбъектовМетаданных = ПравилоКонтроляМетаданных.Значение;
		
		Для Каждого КонтролируемыйОбъектМетаданных Из КонтролируемыеОбъектыМетаданных Цикл
			
			// 1. Проверка объекта метаданных на разделение несколькими разделителями.
			
			ЧислоРазделителей = 0;
			Для Каждого СтандартныйРазделитель Из СтандартныеРазделители Цикл
				Если ЭтоРазделенныйОбъектМетаданных(КонтролируемыйОбъектМетаданных, СтандартныйРазделитель.Имя) Тогда
					ЧислоРазделителей = ЧислоРазделителей + 1;
				КонецЕсли;
			КонецЦикла;
			
			Если ЧислоРазделителей > 1 Тогда
				НарушенияКонтроляРазделенияОбъектовНесколькимиРазделителями.Добавить(КонтролируемыйОбъектМетаданных);
				ОбъектыМетаданныхСНарушениями.Добавить(КонтролируемыйОбъектМетаданных);
			КонецЕсли;
			
			// 2. Проверка неразделенных объектов метаданных на включение в состав контролирующих
			// подписок на события.
			
			Если ЗначениеЗаполнено(КонструкторТипаОбъектовМетаданных) Тогда
				
				Если Исключения.Найти(КонтролируемыйОбъектМетаданных) <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				
				ТипОбъектаМетаданных = Тип(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(КонструкторТипаОбъектовМетаданных, КонтролируемыйОбъектМетаданных.Имя));
				
				ТребуетсяКонтроль = Истина;
				Для Каждого СтандартныйРазделитель Из СтандартныеРазделители Цикл
					
					Если ЭтоРазделенныйОбъектМетаданных(КонтролируемыйОбъектМетаданных, СтандартныйРазделитель.Имя) Тогда
						
						ТребуетсяКонтроль = Ложь;
						
					КонецЕсли;
					
				КонецЦикла;
				
				ОбеспеченКонтроль = Ложь;
				Если ТребуетсяКонтроль Тогда
					
					Для Каждого КонтролирующаяПодписка Из КонтролирующиеПодписки Цикл
						
						Если КонтролирующаяПодписка.Источник.СодержитТип(ТипОбъектаМетаданных) Тогда
							ОбеспеченКонтроль = Истина;
						КонецЕсли;
						
					КонецЦикла;
					
				КонецЕсли;
				
				Если ТребуетсяКонтроль И Не ОбеспеченКонтроль Тогда
					НарушенияКонтроляВключенияНеразделенныхДанныхВКонтролирующиеПодписки.Добавить(КонтролируемыйОбъектМетаданных);
					ОбъектыМетаданныхСНарушениями.Добавить(КонтролируемыйОбъектМетаданных);
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	ВызываемыеИсключения = Новый Массив();
	
	ТекстРазделителей = "";
	Для Каждого СтандартныйРазделитель Из СтандартныеРазделители Цикл
		
		Если Не ПустаяСтрока(ТекстРазделителей) Тогда
			ТекстРазделителей = ТекстРазделителей + ", ";
		КонецЕсли;
		
		ТекстРазделителей = ТекстРазделителей + СтандартныйРазделитель.Имя;
		
	КонецЦикла;
	
	Если НарушенияКонтроляВключенияНеразделенныхДанныхВКонтролирующиеПодписки.Количество() > 0 Тогда
		
		ТекстИсключения = "";
		Для Каждого НеконтролируемыйОбъектМетаданных Из НарушенияКонтроляВключенияНеразделенныхДанныхВКонтролирующиеПодписки Цикл
			
			Если Не ПустаяСтрока(ТекстИсключения) Тогда
				ТекстИсключения = ТекстИсключения + ", ";
			КонецЕсли;
			
			ТекстИсключения = ТекстИсключения + НеконтролируемыйОбъектМетаданных.ПолноеИмя();
			
		КонецЦикла;
		
		ТекстПодписок = "";
		Для Каждого КонтролирующаяПодписка Из КонтролирующиеПодписки Цикл
			
			Если Не ПустаяСтрока(ТекстПодписок) Тогда
				ТекстПодписок = ТекстПодписок + ", ";
			КонецЕсли;
			
			ТекстПодписок = ТекстПодписок + КонтролирующаяПодписка.Имя;
			
		КонецЦикла;
		
		ВызываемыеИсключения.Добавить(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Все объекты метаданных, не входящие в состав разделителей БСП (%1),
                  |должны быть включены в состав подписок на события (%2), контролирующих
                  |невозможность записи неразделенных данных в разделенных сеансах.
                  |Следующие объекты метаданных не удовлетворяют этому критерию: %3.'"),
			ТекстРазделителей, ТекстПодписок, ТекстИсключения));
		
	КонецЕсли;
	
	Если НарушенияКонтроляРазделенияОбъектовНесколькимиРазделителями.Количество() > 0 Тогда
		
		ТекстИсключения = "";
		
		Для Каждого НарушающийОбъектМетаданных Из НарушенияКонтроляРазделенияОбъектовНесколькимиРазделителями Цикл
			
			Если Не ПустаяСтрока(ТекстИсключения) Тогда
				ТекстИсключения = ТекстИсключения + ", ";
			КонецЕсли;
			
			ТекстИсключения = ТекстИсключения + НарушающийОбъектМетаданных.ПолноеИмя();
			
		КонецЦикла;
		
		ВызываемыеИсключения.Добавить(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Все объекты метаданных конфигурации должны быть разделены не более чем одним разделителем БСП (%1).
                  |Следующие объекты не удовлетворяют этому критерию: %2'"),
			ТекстРазделителей, ТекстИсключения));
		
	КонецЕсли;
	
	РезультирующееИсключение = "";
	Итератор = 1;
	
	Для Каждого ВызываемоеИсключение Из ВызываемыеИсключения Цикл
		
		Если Не ПустаяСтрока(РезультирующееИсключение) Тогда
			РезультирующееИсключение = РезультирующееИсключение + Символы.ПС + Символы.ВК;
		КонецЕсли;
		
		РезультирующееИсключение = РезультирующееИсключение + Формат(Итератор, "ЧДЦ=0; ЧГ=0") + ". " + ВызываемоеИсключение;
		Итератор = Итератор + 1;
		
	КонецЦикла;
	
	Если Не ПустаяСтрока(РезультирующееИсключение) Тогда
		
		РезультирующееИсключение = НСтр("ru = 'Обнаружены ошибки в структуре метаданных конфигурации:'") + Символы.ПС + Символы.ВК + РезультирующееИсключение;
		
		Если ВызыватьИсключение Тогда
			
			ВызватьИсключение РезультирующееИсключение;
			
		Иначе
			
			Возврат Новый Структура("ОбъектыМетаданных, ТекстИсключения", ОбъектыМетаданныхСНарушениями, РезультирующееИсключение);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Выполняет контроль структуры метаданных по критерию  упорядоченности общих реквизитов
// в дереве метаданных конфигурации.
//
Процедура КонтрольРазделителейПриОбновлении() Экспорт
	
	ПорядокПрикладныхДанных = 99;
	ПорядокВнутреннихДанных = 99;
	
	РазделительПрикладной = Метаданные.ОбщиеРеквизиты.ОбластьДанныхОсновныеДанные;
	РазделительВнутренний = Метаданные.ОбщиеРеквизиты.ОбластьДанныхВспомогательныеДанные;
	
	Итератор = 0;
	Для Каждого ОбщийРеквизитКонфигурации Из Метаданные.ОбщиеРеквизиты Цикл
		
		Если ОбщийРеквизитКонфигурации = РазделительПрикладной Тогда
			ПорядокПрикладныхДанных = Итератор;
		ИначеЕсли ОбщийРеквизитКонфигурации = РазделительВнутренний Тогда
			ПорядокВнутреннихДанных = Итератор;
		КонецЕсли;
		
		Итератор = Итератор + 1;
		
	КонецЦикла;
	
	Если ПорядокПрикладныхДанных <= ПорядокВнутреннихДанных Тогда
		
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Обнаружено нарушение структуры метаданных конфигурации: общий реквизит %1 должен
                  |быть расположен в дереве метаданных конфигурации до общего реквизита
                  |%2 по порядку.'"),
			РазделительВнутренний.Имя,
			РазделительПрикладной.Имя);
		
	КонецЕсли;
	
КонецПроцедуры

// Возвращает минимальную версию библиотеки "1С:Библиотека технологии сервиса", совместно с которой
// возможно использование текущей версии БСП.
//
// Возвращаемое значение:
//   Строка - минимальная поддерживаемая версия БТС в формате РР.{П|ПП}.ЗЗ.СС.
//
Функция ТребуемаяВерсияБТС()
	
	Возврат "1.0.2.1";
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Работа с параметрами ИБ

// Возвращает пустую таблицу параметров ИБ.
//
Функция ШаблонПараметровИБ()
	
	Результат = Новый ТаблицаЗначений;
	Результат.Колонки.Добавить("Имя", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная)));
	Результат.Колонки.Добавить("Описание", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная)));
	Результат.Колонки.Добавить("ЗапретЧтения", Новый ОписаниеТипов("Булево"));
	Результат.Колонки.Добавить("ЗапретЗаписи", Новый ОписаниеТипов("Булево"));
	Результат.Колонки.Добавить("Тип", Новый ОписаниеТипов("ОписаниеТипов"));
	Возврат Результат;
	
КонецФункции

#КонецОбласти
